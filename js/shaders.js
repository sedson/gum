/**
 * The available shaders. File created by bundleShaders.js.
 * To edit shaders, edit the source and re-bundle.
 */

export const shaders = {
  "default": {
    "frag": "#version 300 es\n\nprecision mediump float;\n\nin vec4 vColor;\nout vec4 fragColor;\n\nvoid main() {\nfragColor = vec4(vColor.rgb, 1.0);\n}",
    "vert": "#version 300 es\n\nuniform mat4 uModel;\nuniform mat4 uView;\nuniform mat4 uProjection;\n\nin vec4 aPosition;\nin vec4 aColor;\n\nout vec4 vColor;\n\nvoid main()\n{\nmat4 modelView = uView * uModel;\ngl_Position = uProjection * uView * uModel * aPosition;\nvColor = aColor;\n}"
  },
  "geo": {
    "frag": "#version 300 es\n\nprecision mediump float;\n\nuniform vec3 uEye;\nuniform vec4 uColor;\n\nin vec4 vWorldPosition;\nin vec4 vColor;\nin vec3 vWorldNormal;\nin vec3 vViewNormal;\nin vec3 vSurfaceId;\nin float vDepth;\nin float vId;\n\nout vec4 fragColor;\n\nvoid main() {\nvec3 lightDir = normalize(vec3(3.0, 4.0, 2.0));\nfloat nDotL = clamp(dot(vWorldNormal, lightDir), 0.0, 1.0);\nfloat light = clamp(smoothstep(0.1, 0.4, nDotL) + 0.2, 0.0, 1.0);\nfloat nDotV = dot(vViewNormal, vec3(0.0, 0.0, 1.0));\n\n// fragColor = vec4(vId, nDotV, nDotL, 1.0);\n\n// fragColor = vec4(vec3(light), 1.0);\n\n// fragColor = vec4(vViewNormal * 0.5 + 0.5, 1.0);\nfragColor = vec4(vSurfaceId, 1.0);\n}",
    "vert": "#version 300 es\n\nuniform mat4 uModel;\nuniform mat4 uView;\nuniform mat4 uProjection;\nuniform float uNear;\nuniform float uFar;\nuniform float uObjectId;\nuniform float uAspect;\n\nin vec4 aPosition;\nin vec4 aColor;\n\nin vec4 aNormal;\nin float aSurfaceId;\n\nout vec4 vWorldPosition;\nout vec4 vColor;\nout vec3 vWorldNormal;\nout vec3 vViewNormal;\nout vec3 vSurfaceId;\nout float vDepth;\nout float vId;\n\n/**\n*\n*/\nvec3 hashId(float id) {\nfloat r = fract(mod(id * 25738.32498, 456.221));\nfloat g = fract(mod(id * 565612.08321, 123.1231));\nfloat b = fract(mod(id * 98281.32498, 13.221));\nreturn vec3(r, g, b);\n}\n\n\n/**\n*\n*/\nvoid main() {\ngl_PointSize = 20.0;\nmat4 modelView = uView * uModel;\nmat3 normMatrix = transpose(inverse(mat3(modelView)));\nvViewNormal = normalize(normMatrix * aNormal.xyz);\nvWorldNormal = normalize(mat3(uModel) * aNormal.xyz);\nvColor = aColor;\n\ngl_Position = uProjection * uView * uModel * aPosition;\n\nvec3 rounded = round(gl_Position.xyz * 20.0) / 20.0;\n// gl_Position.xyz = rounded;\n\nfloat id = mod(aSurfaceId + uObjectId, 255.0);\nvId = id / 255.0 + (1.0 / 255.0);\n\nvSurfaceId = hashId(aSurfaceId + uObjectId);\n\nvWorldPosition = gl_Position;\n}"
  },
  "line": {
    "frag": "#version 300 es\n\nprecision mediump float;\n\nuniform vec3 uEye;\n\nin vec4 vColor;\n\nout vec4 fragColor;\n\nvoid main () {\nfragColor = vColor;\n}",
    "vert": "#version 300 es\n\nuniform mat4 uModel;\nuniform mat4 uView;\nuniform mat4 uProjection;\n\nuniform float uNear;\nuniform float uFar;\nuniform float uAspect;\nuniform float uObjectId;\n\nin vec4 aPosition;\nin vec4 aColor;\nin vec4 aRegister1; // .xyz is previous\nin vec4 aRegister2; // .xyz is next\nin vec3 aNormal;    // .x is thickness\n// .y is orinetation\n\nout vec4 vColor;\n\n\n/**\n*\n*/\nvoid main () {\nmat4 mvp = uProjection * uView * uModel;\nvec2 aspect = vec2(uAspect, 1.0);\n\nfloat thickness = aNormal.x;\nfloat orientation = aNormal.y;\n\nvec4 current = mvp * vec4(aPosition.xyz, 1.0);\nvec4 previous = mvp * vec4(aRegister1.xyz, 1.0);\nvec4 next = mvp * vec4(aRegister2.xyz, 1.0);\n\n\n// could use z component to scale by distance.\nvec2 currentScreen = current.xy / current.w * aspect;\nvec2 previousScreen = previous.xy / previous.w * aspect;\nvec2 nextScreen = next.xy / next.w * aspect;\n\nvec2 lineDir = vec2(0.0);\n\nif (currentScreen == previousScreen) {\nlineDir = normalize(nextScreen - currentScreen);\n}\nelse if (currentScreen == nextScreen) {\nlineDir = normalize(currentScreen - previousScreen);\n}\nelse {\nvec2 dirA = normalize(currentScreen - previousScreen);\nif (orientation == 1.0) {\nvec2 dirB = normalize(nextScreen - currentScreen);\n\nvec2 tangent = normalize(dirA + dirB);\nvec2 perp = vec2(-dirA.y, dirA.x);\nvec2 miter = vec2(-tangent.y, tangent.x);\n\nlineDir = tangent;\nthickness = thickness / dot(miter, perp);\n\nthickness = clamp(thickness, 0.0, aNormal.x * 3.0);\n\n} else {\nlineDir = dirA;\n}\n}\n\nvec2 normal = vec2(-lineDir.y, lineDir.x) * thickness * 0.5;\nnormal.x /= uAspect;\n\nvec4 offset = vec4(normal * orientation, 0.0, 0.0);\n\ngl_Position = current + offset;\nvColor = aColor;\n}"
  },
  "post-blur": {
    "frag": "#version 300 es\n\nprecision mediump float;\n\nuniform sampler2D uMainTex;\nuniform sampler2D uDepthTex;\nuniform vec2 uTexSize;\n\nin vec2 vTexCoord;\nout vec4 fragColor;\n\nconst float kernel = 2.0;\nconst float dist = 2.0;\nconst float weight = 1.0;\n\nvec4 gradient(sampler2D tex, vec2 coord) {\nvec2 offset = vec2(1.0, 1.0) / uTexSize;\n\nvec4 xSum = vec4(0.0);\nvec4 ySum = vec4(0.0);\n\nxSum += texture(tex, coord + vec2(-offset.x, 0.0)) * -1.0;\nxSum += texture(tex, coord + vec2(+offset.x, 0.0));\n\nySum += texture(tex, coord + vec2(0.0, -offset.y)) * -1.0;\nySum += texture(tex, coord + vec2(0.0, +offset.y));\n\nreturn sqrt(xSum * xSum + ySum * ySum);\n}\n\nvoid main() {\nvec4 col = texture(uMainTex, vTexCoord);\n\nvec3 accum = vec3(0.0);\nvec3 weightSum = vec3(0.0);\n\nvec2 pix = vec2(1.0, 1.0) / uTexSize;\n\n\n\nfor (float i = -kernel; i <= kernel; i++) {\nfor (float j = -kernel; j <= kernel; j++) {\nvec2 sampleCoord = vTexCoord + (vec2(i, j) * pix);\naccum += texture(uMainTex, sampleCoord).rgb * weight;\nweightSum += weight;\n}\n}\n\nvec3 avg = accum / weightSum;\n\n\nfragColor = vec4(avg, 1.0);\n\n}"
  },
  "post-chromatic": {
    "frag": "#version 300 es\n\nprecision mediump float;\n\nuniform sampler2D uMainTex;\nuniform sampler2D uDepthTex;\nuniform vec2 uTexSize;\nuniform float uNear;\nuniform float uFar;\n\n\nin vec2 vTexCoord;\nout vec4 fragColor;\n\n\nvoid main() {\nvec2 rOff = vec2(0.0, 4.0);\nvec2 gOff = vec2(0.0, 0.0);\nvec2 bOff = vec2(4.0, 0.0);\nvec2 pixelSize = 1.0 / uTexSize;\nvec4 col = texture(uMainTex, vTexCoord);\n\nfragColor = col;\nfloat r = texture(uMainTex, vTexCoord + (pixelSize * rOff)).r;\nfloat g = texture(uMainTex, vTexCoord + (pixelSize * gOff)).g;\nfloat b = texture(uMainTex, vTexCoord + (pixelSize * bOff)).b;\n\nfragColor.rgb = vec3(r, g, b);\n\n// vec2 uv = vTexCoord;\n// uv *= 1.0 - uv.xy;\n\n// float vig = uv.x * uv.y * 15.0;\n\n// vig = pow(vig, 0.03);\n\n// fragColor.rgb *= vig;\n}"
  },
  "post-outline": {
    "frag": "#version 300 es\n\nprecision mediump float;\n\nuniform sampler2D uMainTex;\nuniform sampler2D uDepthTex;\nuniform vec2 uTexSize;\nuniform float uNear;\nuniform float uFar;\n\nin vec2 vTexCoord;\nout vec4 fragColor;\n\nfloat linearDepth(float d, float near, float far) {\nfloat z = d * 2.0 - 1.0;\nreturn (2.0 * near * far) / (far + near - d * (far - near)) / far;\n}\n\nvec4 gradient(sampler2D tex, vec2 coord) {\nvec2 offset = vec2(1.0, 1.0) / uTexSize;\n\nvec4 xSum = vec4(0.0);\nvec4 ySum = vec4(0.0);\n\nxSum += texture(tex, coord + vec2(-offset.x, 0.0)) * -1.0;\nxSum += texture(tex, coord + vec2(+offset.x, 0.0));\n\nySum += texture(tex, coord + vec2(0.0, -offset.y)) * -1.0;\nySum += texture(tex, coord + vec2(0.0, +offset.y));\n\nreturn sqrt(xSum * xSum + ySum * ySum);\n}\n\nvoid main() {\nvec4 col = texture(uMainTex, vTexCoord);\nfloat depth = texture(uDepthTex, vTexCoord).r;\nfloat lDepth = linearDepth(depth, uNear, uFar);\n\nvec4 colGrad = gradient(uMainTex, vTexCoord);\nvec4 depthGrad = gradient(uDepthTex, vTexCoord);\n\nfloat idQ = mix(colGrad.r, 0.0, smoothstep(0.0, 0.3, lDepth));\n\nfloat idEdge = step(0.0001, colGrad.x);\n\nfloat depthQ = mix(0.0, 100.0, smoothstep(0.0, 0.01, col.g));\n\nfloat depthEdge = step(0.01, depthGrad.r);\n\nfloat normEdge = step(0.3, colGrad.g);\n\nfloat edge = max(idEdge, depthEdge);\n\nvec3 grad = vec3(idEdge, depthEdge, 0.0);\n\nfloat fog = smoothstep(4.0, 40.0, lDepth * (uFar - uNear));\n\n// float surfaceId = round(col.r * 20.0);\nfragColor.rgb = mix(vec3(0.2, 0.2, 0.2), vec3(0.6, 0.5, 0.5), 1.0 - fog);\n// fragColor.rgb *= 1.0 - ((1.0 - fog) * edge);\n// fragColor.a = 1.0;\n\nfragColor = vec4(vec3(edge * 0.4 + 0.1), 1.0);\n\n// fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n\n// fragColor = vec4(mix(vec3(1.0, 1.0, 0.2), vec3(0.1, 0.1, 0.1), edge), 1.0);\n\n// fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n// fragColor = vec4(vec3(idEdge), 1.0);\n// fragColor = vec4(colGrad.ggg, 1.0);\n// fragColor = vec4(1.0, 0.0, 1.0, 1.0);\n// fragColor = vec4(vec3(fog), 1.0);\n\n}"
  },
  "post-outline2": {
    "frag": "#version 300 es\n\nprecision mediump float;\n\nuniform sampler2D uMainTex;\nuniform sampler2D uDepthTex;\nuniform vec2 uTexSize;\nuniform float uNear;\nuniform float uFar;\n\nin vec2 vTexCoord;\nout vec4 fragColor;\n\nfloat linearDepth(float d, float near, float far) {\nfloat z = d * 2.0 - 1.0;\nreturn (2.0 * near * far) / (far + near - d * (far - near)) / far;\n}\n\nvec4 gradient(sampler2D tex, vec2 coord) {\nvec2 offset = vec2(1.0, 1.0) / uTexSize;\n\nvec4 xSum = vec4(0.0);\nvec4 ySum = vec4(0.0);\n\nxSum += texture(tex, coord + vec2(-offset.x, 0.0)) * -1.0;\nxSum += texture(tex, coord + vec2(+offset.x, 0.0));\n\nySum += texture(tex, coord + vec2(0.0, -offset.y)) * -1.0;\nySum += texture(tex, coord + vec2(0.0, +offset.y));\n\nreturn sqrt(xSum * xSum + ySum * ySum);\n}\n\nvoid main() {\nvec4 col = texture(uMainTex, vTexCoord);\nfloat depth = texture(uDepthTex, vTexCoord).r;\nfloat lDepth = linearDepth(depth, uNear, uFar);\n\nvec4 colGrad = gradient(uMainTex, vTexCoord);\nvec4 depthGrad = gradient(uDepthTex, vTexCoord);\n\nfloat idQ = mix(colGrad.r, 0.0, smoothstep(0.0, 0.3, lDepth));\n\nfloat idEdge = step(0.0001, colGrad.x);\n\nfloat depthQ = mix(0.0, 100.0, smoothstep(0.0, 0.01, col.g));\n\nfloat depthEdge = step(0.01, depthGrad.r);\n\nfloat normEdge = step(0.3, colGrad.g);\n\nfloat edge = max(idEdge, depthEdge);\n\nvec3 grad = vec3(idEdge, depthEdge, 0.0);\n\nfloat fog = smoothstep(4.0, 40.0, lDepth * (uFar - uNear));\n\n// float surfaceId = round(col.r * 20.0);\nfragColor.rgb = mix(vec3(0.2, 0.2, 0.2), vec3(0.6, 0.5, 0.5), 1.0 - fog);\n// fragColor.rgb *= 1.0 - ((1.0 - fog) * edge);\n// fragColor.a = 1.0;\n\nfragColor.rgb = mix(col.rgb, vec3(0.1), edge);\nfragColor.a = 1.0;\n\n\n\n\n// fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n// fragColor = vec4(vec3(depthEdge), 1.0);\n// fragColor = vec4(colGrad.ggg, 1.0);\n// fragColor = vec4(1.0, 0.0, 1.0, 1.0);\n// fragColor = vec4(vec3(fog), 1.0);\n\n}"
  },
  "post": {
    "vert": "#version 300 es\n\nin vec2 aPosition;\nout vec2 vTexCoord;\n\nvoid main() {\nvTexCoord = (aPosition + 1.0) / 2.0;\ngl_Position = vec4(aPosition, 0.0, 1.0);\n}"
  },
  "textured": {
    "frag": "#version 300 es\n\nprecision mediump float;\n\nuniform sampler2D uTex;\n\nin vec4 vColor;\nin vec2 vTexCoord;\nout vec4 fragColor;\n\nvoid main() {\nfragColor.rg = vTexCoord;\nfragColor.a = 1.0;\n\nfragColor = texture(uTex, vTexCoord);\n}",
    "vert": "#version 300 es\n\nuniform mat4 uModel;\nuniform mat4 uView;\nuniform mat4 uProjection;\n\nuniform float uObjectId;\n\nin vec4 aPosition;\nin vec3 aNormal;\nin vec2 aTexCoord;\nin vec4 aColor;\nin float aSurfaceId;\n\nout vec4 vColor;\nout vec2 vTexCoord;\n\nvec3 hashId(float id) {\nfloat r = fract(mod(id * 25738.32498, 456.221));\nfloat g = fract(mod(id * 565612.08321, 123.1231));\nfloat b = fract(mod(id * 98281.32498, 13.221));\nreturn vec3(r, g, b);\n}\n\nvoid main() {\nmat4 modelView = uView * uModel;\ngl_Position = uProjection * uView * uModel * aPosition;\nvColor = aColor;\nvTexCoord = aTexCoord;\n}"
  },
  "unlit": {
    "frag": "#version 300 es\n\nprecision mediump float;\n\nin vec4 vColor;\nout vec4 fragColor;\n\nvoid main() {\nfragColor = vec4(vColor.rgb, 1.0);\n}",
    "vert": "#version 300 es\n\nuniform mat4 uModel;\nuniform mat4 uView;\nuniform mat4 uProjection;\n\nuniform float uObjectId;\n\nin vec4 aPosition;\nin vec3 aNormal;\nin vec4 aColor;\nin float aSurfaceId;\n\nout vec4 vColor;\n\nvec3 hashId (float id)\n{\nfloat r = fract(mod(id * 25738.32498, 456.221));\nfloat g = fract(mod(id * 565612.08321, 123.1231));\nfloat b = fract(mod(id * 98281.32498, 13.221));\nreturn vec3(r, g, b);\n}\n\nvoid main()\n{\nmat4 modelView = uView * uModel;\ngl_Position = uProjection * uView * uModel * aPosition;\n\n\nvec3 vertexColor = aColor.rgb;\nvec3 localNormal = aNormal.rgb * 0.5 + 0.5;\nvec3 surfaceId = hashId(uObjectId + aSurfaceId);\n\nvColor.a = 1.0;\nvColor.rgb = vertexColor;\n}"
  }
};
