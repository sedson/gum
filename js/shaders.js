/**
 * The available shaders. File created by bundleShaders.js.
 * To edit shaders, edit the source and re-bundle.
 */

export const shaders = {
  "default": {
    "frag": "#version 300 es\n\nprecision mediump float;\n\nin vec4 vColor;\nout vec4 fragColor;\n\nvoid main() {\nfragColor = vec4(vColor.rgb, 1.0);\n}",
    "vert": "#version 300 es\n\nuniform mat4 uModel;\nuniform mat4 uView;\nuniform mat4 uProjection;\n\nin vec4 aPosition;\nin vec4 aColor;\n\nout vec4 vColor;\n\nvoid main()\n{\nmat4 modelView = uView * uModel;\ngl_Position = uProjection * uView * uModel * vec4(aPosition.xyz, 1.0);\nvColor = aColor;\n}"
  },
  "geo": {
    "frag": "#version 300 es\n\nprecision mediump float;\n\nuniform vec3 uEye;\nuniform vec4 uColor;\n\nin vec4 vWorldPosition;\nin vec4 vColor;\nin vec3 vWorldNormal;\nin vec3 vViewNormal;\nin vec3 vSurfaceId;\nin float vDepth;\nin float vId;\n\nout vec4 fragColor;\n\nvoid main() {\nvec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\nfloat nDotL = clamp(dot(vWorldNormal, lightDir), 0.0, 1.0);\nfloat light = clamp(smoothstep(0.1, 0.4, nDotL) + 0.2, 0.0, 1.0);\nfloat nDotV = dot(vViewNormal, vec3(0.0, 0.0, 1.0));\n\nfragColor = vec4(vId, nDotV, nDotL, 1.0);\n\n// fragColor = vec4(vec3(light), 1.0);\n\n// fragColor = vec4(vViewNormal * 0.5 + 0.5, 1.0);\nfragColor = vec4(vSurfaceId, 1.0);\n}",
    "vert": "#version 300 es\n\nuniform mat4 uModel;\nuniform mat4 uView;\nuniform mat4 uProjection;\nuniform float uNear;\nuniform float uFar;\nuniform float uObjectId;\nuniform float uAspect;\n\nin vec4 aPosition;\nin vec4 aColor;\n\nin vec4 aNormal;\nin float aSurfaceId;\n\nout vec4 vWorldPosition;\nout vec4 vColor;\nout vec3 vWorldNormal;\nout vec3 vViewNormal;\nout vec3 vSurfaceId;\nout float vDepth;\nout float vId;\n\n/**\n*\n*/\nvec3 hashId(float id) {\nfloat r = fract(mod(id * 25738.32498, 456.221));\nfloat g = fract(mod(id * 565612.08321, 123.1231));\nfloat b = fract(mod(id * 98281.32498, 13.221));\nreturn vec3(r, g, b);\n}\n\n\n/**\n*\n*/\nvoid main() {\ngl_PointSize = 20.0;\nmat4 modelView = uView * uModel;\nmat3 normMatrix = transpose(inverse(mat3(modelView)));\nvViewNormal = normalize(normMatrix * aNormal.xyz);\nvWorldNormal = normalize(mat3(uModel) * aNormal.xyz);\nvColor = aColor;\n\ngl_Position = uProjection * uView * uModel * aPosition;\n\nvec3 rounded = round(gl_Position.xyz * 20.0) / 20.0;\n// gl_Position.xyz = rounded;\n\nfloat id = mod(aSurfaceId + uObjectId, 255.0);\nvId = id / 255.0 + (1.0 / 255.0);\n\nvSurfaceId = hashId(aSurfaceId + uObjectId);\n\nvWorldPosition = gl_Position;\n}"
  },
  "line": {
    "frag": "#version 300 es\n\nprecision mediump float;\n\nuniform vec3 uEye;\n\nin vec4 vColor;\n\nout vec4 fragColor;\n\nvoid main () {\nfragColor = vColor;\n}",
    "vert": "#version 300 es\n\nuniform mat4 uModel;\nuniform mat4 uView;\nuniform mat4 uProjection;\n\nuniform float uNear;\nuniform float uFar;\nuniform float uAspect;\nuniform float uObjectId;\n\nin vec4 aPosition;\nin vec4 aColor;\nin vec4 aRegister1; // .xyz is previous\nin vec4 aRegister2; // .xyz is next\nin vec3 aNormal;    // .x is thickness\n// .y is orinetation\n\nout vec4 vColor;\n\n\n/**\n*\n*/\nvoid main () {\nmat4 mvp = uProjection * uView * uModel;\nvec2 aspect = vec2(uAspect, 1.0);\n\nfloat thickness = aNormal.x;\nfloat orientation = aNormal.y;\n\nvec4 current = mvp * vec4(aPosition.xyz, 1.0);\nvec4 previous = mvp * vec4(aRegister1.xyz, 1.0);\nvec4 next = mvp * vec4(aRegister2.xyz, 1.0);\n\n\n// could use z component to scale by distance.\nvec2 currentScreen = current.xy / current.w * aspect;\nvec2 previousScreen = previous.xy / previous.w * aspect;\nvec2 nextScreen = next.xy / next.w * aspect;\n\nvec2 lineDir = vec2(0.0);\n\nif (currentScreen == previousScreen) {\nlineDir = normalize(nextScreen - currentScreen);\n}\nelse if (currentScreen == nextScreen) {\nlineDir = normalize(currentScreen - previousScreen);\n}\nelse {\nvec2 dirA = normalize(currentScreen - previousScreen);\nif (orientation == 1.0) {\nvec2 dirB = normalize(nextScreen - currentScreen);\n\nvec2 tangent = normalize(dirA + dirB);\nvec2 perp = vec2(-dirA.y, dirA.x);\nvec2 miter = vec2(-tangent.y, tangent.x);\n\nlineDir = tangent;\nthickness = thickness / dot(miter, perp);\n\nthickness = clamp(thickness, 0.0, aNormal.x * 3.0);\n\n} else {\nlineDir = dirA;\n}\n}\n\nvec2 normal = vec2(-lineDir.y, lineDir.x) * thickness * 0.5;\nnormal.x /= uAspect;\n\nvec4 offset = vec4(normal * orientation, 0.0, 0.0);\n\ngl_Position = current + offset;\nvColor = aColor;\n}"
  },
  "line2": {
    "frag": "#version 300 es\n\nprecision mediump float;\n\nuniform vec3 uEye;\n\nin vec4 vColor;\n\nout vec4 fragColor;\n\nvoid main () {\nfragColor = vColor;\n}",
    "vert": "#version 300 es\n\nuniform mat4 uModel;\nuniform mat4 uView;\nuniform mat4 uProjection;\n\nuniform float uNear;\nuniform float uFar;\nuniform float uAspect;\nuniform float uObjectId;\n\nin vec3 aPosition;\nin vec4 aColor;\nin vec4 aRegister1; // .xyz is next\nin vec3 aNormal;    // .x is thickness\n// .y is corner index\n\nout vec4 vColor;\n\n\n/**\n*\n*/\nvoid main () {\nmat4 mvp = uProjection * uView * uModel;\nvec2 aspect = vec2(uAspect, 1.0);\n\nfloat thickness = aNormal.x;\nfloat orientation = aNormal.y;\n\nfloat extension = thickness * 0.25;\n\nvec4 current = mvp * vec4(aPosition.xyz, 1.0);\nvec4 next = mvp * vec4(aRegister1.xyz, 1.0);\n\n// could use z component to scale by distance.\nvec2 currentScreen = current.xy / current.w;\nvec2 nextScreen = next.xy / next.w;\n\nvec2 lineDir = normalize(nextScreen - currentScreen);\n\n\nvec2 normal = vec2(-lineDir.y, lineDir.x) * 0.5 * thickness;\n\nnormal.x /= uAspect;\n\n\nif (aNormal.y < 1.0) {\n\ncurrent.xy -= normal;\ncurrent.xy -= lineDir * extension;\ngl_Position = current;\n\n} else if (aNormal.y < 2.0) {\n\ncurrent.xy += normal;\ncurrent.xy -= lineDir * extension;\ngl_Position = current;\n\n} else if (aNormal.y < 3.0) {\n\nnext.xy -= normal;\nnext.xy += lineDir * extension;\ngl_Position = next;\n\n} else {\n\nnext.xy += normal;\nnext.xy += lineDir * extension;\ngl_Position = next;\n\n}\n\nvColor = aColor;\n}"
  },
  "lit": {
    "frag": "#version 300 es\n\nprecision mediump float;\n\nin vec4 vColor;\nin vec3 vNormal;\n\nout vec4 fragColor;\n\nvoid main() {\nif (!gl_FrontFacing) {\nfragColor = vec4(1.0, 0.0, 0.0, 1.0);\nreturn;\n}\n\nvec3 l = normalize(vec3(1.0, 1.0, 1.0));\nfloat ndotl = dot(normalize(vNormal), l);\n\nndotl = clamp(ndotl, 0.0, 1.0);\n\n\nfragColor = vec4(vColor.rgb * ndotl, 1.0);\n\n// fragColor = vec4(vNormal, 1.0);\n\n}",
    "vert": "#version 300 es\n\nuniform mat4 uModel;\nuniform mat4 uView;\nuniform mat4 uProjection;\n\nuniform float uObjectId;\n\nin vec4 aPosition;\nin vec3 aNormal;\nin vec4 aColor;\nin float aSurfaceId;\n\nout vec4 vColor;\nout vec3 vNormal;\n\nvoid main()\n{\ngl_Position = uProjection * uView * uModel * aPosition;\nmat3 normMatrix = transpose(inverse(mat3(uView * uModel)));\nvColor = aColor;\nvNormal = transpose(inverse(mat3(uModel))) * aNormal;\n}"
  },
  "noise": {
    "glsl": "float rand (float n) {\nreturn fract(sin(n) * 43748.5453123);\n}\n\nfloat rand (vec2 n) {\nreturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat bnoise (float p) {\nfloat pInt = floor(p);\nfloat pFract = fract(p);\nreturn mix(rand(pInt), rand(pInt + 1.0), pFract);\n}\n\nfloat bnoise (vec2 p) {\nvec2 d = vec2(0.0, 1.0);\nvec2 b = floor(p);\nvec2 f = smoothstep(vec2(0.0), vec2(1.0), fract(p));\nreturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}"
  },
  "post-blur": {
    "frag": "#version 300 es\n\nprecision mediump float;\n\n// Defualt uniforms.\nuniform sampler2D uMainTex;\nuniform sampler2D uDepthTex;\nuniform vec2 uTexSize;\n\n// Custom uniforms.\nuniform float uKernel;\nuniform float uDist;\nuniform float uWeight;\n\nin vec2 vTexCoord;\nout vec4 fragColor;\n\n\nvoid main() {\nvec4 col = texture(uMainTex, vTexCoord);\n\nvec3 accum = vec3(0.0);\nvec3 weightSum = vec3(0.0);\n\nvec2 pix = vec2(uDist, uDist) / uTexSize;\n\n\n\nfor (float i = -uKernel; i <= uKernel; i++) {\nfor (float j = -uKernel; j <= uKernel; j++) {\nvec2 sampleCoord = vTexCoord + (vec2(i, j) * pix);\naccum += texture(uMainTex, sampleCoord).rgb * uWeight;\nweightSum += uWeight;\n}\n}\n\nvec3 avg = accum / weightSum;\n\n\nfragColor = vec4(avg, 1.0);\n\n}"
  },
  "post-chromatic": {
    "frag": "#version 300 es\n\nprecision mediump float;\n\nuniform sampler2D uMainTex;\nuniform sampler2D uDepthTex;\nuniform vec2 uTexSize;\nuniform float uNear;\nuniform float uFar;\n\n\nin vec2 vTexCoord;\nout vec4 fragColor;\n\n\nvoid main() {\nvec2 rOff = vec2(0.0, 4.0);\nvec2 gOff = vec2(0.0, 0.0);\nvec2 bOff = vec2(4.0, 0.0);\nvec2 pixelSize = 1.0 / uTexSize;\nvec4 col = texture(uMainTex, vTexCoord);\n\nfragColor = col;\nfloat r = texture(uMainTex, vTexCoord + (pixelSize * rOff)).r;\nfloat g = texture(uMainTex, vTexCoord + (pixelSize * gOff)).g;\nfloat b = texture(uMainTex, vTexCoord + (pixelSize * bOff)).b;\n\nfragColor.rgb = vec3(r, g, b);\n\n// vec2 uv = vTexCoord;\n// uv *= 1.0 - uv.xy;\n\n// float vig = uv.x * uv.y * 15.0;\n\n// vig = pow(vig, 0.03);\n\n// fragColor.rgb *= vig;\n}"
  },
  "post-dither": {
    "frag": "#version 300 es\nprecision mediump float;\n\n// Defualt uniforms.\nuniform sampler2D uMainTex;\nuniform sampler2D uDepthTex;\nuniform vec2 uTexSize;\n\n// Custom uniforms.\nuniform vec4 uColorA;\nuniform vec4 uColorB;\n\n\nin vec2 vTexCoord;\nout vec4 fragColor;\n\nfloat rand (float n) {\n  return fract(sin(n) * 43748.5453123);\n}\n\nfloat rand (vec2 n) {\n  return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat bnoise (float p) {\n  float pInt = floor(p);\n  float pFract = fract(p);\n  return mix(rand(pInt), rand(pInt + 1.0), pFract);\n}\n\nfloat bnoise (vec2 p) {\n  vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(p);\n  vec2 f = smoothstep(vec2(0.0), vec2(1.0), fract(p));\n  return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nconst int[64] BAYER64 = int[](\n0, 32, 8, 40, 2, 34, 10, 42,    /* 8x8 Bayer ordered dithering */\n48, 16, 56, 24, 50, 18, 58, 26, /* pattern. Each input pixel */\n12, 44, 4, 36, 14, 46, 6, 38,   /* is scaled to the 0..63 range */\n60, 28, 52, 20, 62, 30, 54, 22, /* before looking in this table */\n3, 35, 11, 43, 1, 33, 9, 41,    /* to determine the action. */\n51, 19, 59, 27, 49, 17, 57, 25,\n15, 47, 7, 39, 13, 45, 5, 37,\n63, 31, 55, 23, 61, 29, 53, 21\n);\n\nvoid main() {\nvec4 col = texture(uMainTex, vTexCoord);\nfloat brightness = dot(col.rgb, vec3(0.2126, 0.7152, 0.0722));\n\nvec2 xy = vTexCoord * uTexSize;\n\nint x = int(mod(xy.x, 8.0));\nint y = int(mod(xy.y, 8.0));\n\nfloat n = float(BAYER64[y * 8 + x]);\n\nbrightness += (bnoise(vTexCoord * uTexSize) * 2.0 - 1.0) * 0.0;\n\nfloat pix = step(n, brightness * 63.0);\n\n\nvec3 rgb = mix(uColorB.rgb,  uColorA.rgb, pix);\nfragColor = vec4(rgb, 1.0);\n// fragColor = vec4(vec3(noise), 1.0);\n\n// fragColor = vec4(gl_FragCoord.xy / uTexSize, 0.0, 1.0);\n\n}"
  },
  "post-outline": {
    "frag": "#version 300 es\n\nprecision mediump float;\n\nuniform sampler2D uMainTex;\nuniform sampler2D uDepthTex;\nuniform vec2 uTexSize;\nuniform float uNear;\nuniform float uFar;\n\nin vec2 vTexCoord;\nout vec4 fragColor;\n\nfloat linearDepth(float d, float near, float far) {\nfloat z = d * 2.0 - 1.0;\nreturn (2.0 * near * far) / (far + near - d * (far - near)) / far;\n}\n\nvec4 gradient(sampler2D tex, vec2 coord) {\nvec2 offset = vec2(1.0, 1.0) / uTexSize;\n\nvec4 xSum = vec4(0.0);\nvec4 ySum = vec4(0.0);\n\nxSum += texture(tex, coord + vec2(-offset.x, 0.0)) * -1.0;\nxSum += texture(tex, coord + vec2(+offset.x, 0.0));\n\nySum += texture(tex, coord + vec2(0.0, -offset.y)) * -1.0;\nySum += texture(tex, coord + vec2(0.0, +offset.y));\n\nreturn sqrt(xSum * xSum + ySum * ySum);\n}\n\nvoid main() {\nvec4 col = texture(uMainTex, vTexCoord);\nfloat depth = texture(uDepthTex, vTexCoord).r;\nfloat lDepth = linearDepth(depth, uNear, uFar);\n\nvec4 colGrad = gradient(uMainTex, vTexCoord);\nvec4 depthGrad = gradient(uDepthTex, vTexCoord);\n\nfloat idQ = mix(colGrad.r, 0.0, smoothstep(0.0, 0.3, lDepth));\n\nfloat idEdge = step(0.0001, colGrad.x);\n\nfloat depthQ = mix(0.0, 100.0, smoothstep(0.0, 0.01, col.g));\n\nfloat depthEdge = step(0.01, depthGrad.r);\n\nfloat normEdge = step(0.3, colGrad.g);\n\nfloat edge = max(idEdge, depthEdge);\n\nvec3 grad = vec3(idEdge, depthEdge, 0.0);\n\nfloat fog = smoothstep(4.0, 40.0, lDepth * (uFar - uNear));\n\n// float surfaceId = round(col.r * 20.0);\nfragColor.rgb = mix(vec3(0.2, 0.2, 0.2), vec3(0.6, 0.5, 0.5), 1.0 - fog);\n// fragColor.rgb *= 1.0 - ((1.0 - fog) * edge);\n// fragColor.a = 1.0;\n\nfragColor = vec4(vec3(edge * 0.4 + 0.1), 1.0);\n\n// fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n\n// fragColor = vec4(mix(vec3(1.0, 1.0, 0.2), vec3(0.1, 0.1, 0.1), edge), 1.0);\n\n// fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n// fragColor = vec4(vec3(idEdge), 1.0);\n// fragColor = vec4(colGrad.ggg, 1.0);\n// fragColor = vec4(1.0, 0.0, 1.0, 1.0);\n// fragColor = vec4(vec3(fog), 1.0);\n\n}"
  },
  "post-outline2": {
    "frag": "#version 300 es\n\nprecision mediump float;\n\nuniform sampler2D uMainTex;\nuniform sampler2D uDepthTex;\nuniform vec2 uTexSize;\nuniform float uNear;\nuniform float uFar;\n\nin vec2 vTexCoord;\nout vec4 fragColor;\n\nfloat linearDepth(float d, float near, float far) {\nfloat z = d * 2.0 - 1.0;\nreturn (2.0 * near * far) / (far + near - d * (far - near)) / far;\n}\n\nvec4 gradient(sampler2D tex, vec2 coord) {\nvec2 offset = vec2(1.0, 1.0) / uTexSize;\n\nvec4 xSum = vec4(0.0);\nvec4 ySum = vec4(0.0);\n\nxSum += texture(tex, coord + vec2(-offset.x, 0.0)) * -1.0;\nxSum += texture(tex, coord + vec2(+offset.x, 0.0));\n\nySum += texture(tex, coord + vec2(0.0, -offset.y)) * -1.0;\nySum += texture(tex, coord + vec2(0.0, +offset.y));\n\nreturn sqrt(xSum * xSum + ySum * ySum);\n}\n\nvoid main() {\nvec4 col = texture(uMainTex, vTexCoord);\nfloat depth = texture(uDepthTex, vTexCoord).r;\nfloat lDepth = linearDepth(depth, uNear, uFar);\n\nvec4 colGrad = gradient(uMainTex, vTexCoord);\nvec4 depthGrad = gradient(uDepthTex, vTexCoord);\n\nfloat idQ = mix(colGrad.r, 0.0, smoothstep(0.0, 0.3, lDepth));\n\nfloat idEdge = step(0.0001, colGrad.x);\n\nfloat depthQ = mix(0.0, 100.0, smoothstep(0.0, 0.01, col.g));\n\nfloat depthEdge = step(0.01, depthGrad.r);\n\nfloat normEdge = step(0.3, colGrad.g);\n\nfloat edge = max(idEdge, depthEdge);\n\nvec3 grad = vec3(idEdge, depthEdge, 0.0);\n\nfloat fog = smoothstep(4.0, 40.0, lDepth * (uFar - uNear));\n\n// float surfaceId = round(col.r * 20.0);\nfragColor.rgb = mix(vec3(0.2, 0.2, 0.2), vec3(0.6, 0.5, 0.5), 1.0 - fog);\n// fragColor.rgb *= 1.0 - ((1.0 - fog) * edge);\n// fragColor.a = 1.0;\n\nfragColor.rgb = mix(col.rgb, vec3(0.1), edge);\nfragColor.a = 1.0;\n\n\n\n\n// fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n// fragColor = vec4(vec3(depthEdge), 1.0);\n// fragColor = vec4(colGrad.ggg, 1.0);\n// fragColor = vec4(1.0, 0.0, 1.0, 1.0);\n// fragColor = vec4(vec3(fog), 1.0);\n\n}"
  },
  "post": {
    "vert": "#version 300 es\n\nin vec2 aPosition;\nout vec2 vTexCoord;\n\nvoid main() {\nvTexCoord = (aPosition + 1.0) / 2.0;\ngl_Position = vec4(aPosition, 0.0, 1.0);\n}"
  },
  "textured": {
    "frag": "#version 300 es\n\nprecision mediump float;\n\nuniform sampler2D uTex;\n\nin vec4 vColor;\nin vec2 vTexCoord;\nout vec4 fragColor;\n\nvoid main() {\nfragColor.rg = vTexCoord;\nfragColor.a = 1.0;\n\nfragColor = texture(uTex, vTexCoord);\n// fragColor = vec4(vTexCoord, 0.0, 1.0);\n// float f = smoothstep(0.39, 0.4, distance(vTexCoord, vec2(0.5, 0.5)));\n// fragColor = vec4(vec3(f), 1.0);\n}",
    "vert": "#version 300 es\n\nuniform mat4 uModel;\nuniform mat4 uView;\nuniform mat4 uProjection;\n\nuniform float uObjectId;\n\nin vec4 aPosition;\nin vec3 aNormal;\nin vec2 aTexCoord;\nin vec4 aColor;\nin float aSurfaceId;\n\nout vec4 vColor;\nout vec2 vTexCoord;\n\nvec3 hashId(float id) {\nfloat r = fract(mod(id * 25738.32498, 456.221));\nfloat g = fract(mod(id * 565612.08321, 123.1231));\nfloat b = fract(mod(id * 98281.32498, 13.221));\nreturn vec3(r, g, b);\n}\n\nvoid main() {\nmat4 modelView = uView * uModel;\ngl_Position = uProjection * uView * uModel * aPosition;\nvColor = aColor;\nvTexCoord = aTexCoord;\n}"
  },
  "unlit": {
    "frag": "#version 300 es\n\nprecision mediump float;\n\nin vec4 vColor;\nout vec4 fragColor;\n\nvoid main() {\nfragColor = vec4(vColor.rgb, 1.0);\n}",
    "vert": "#version 300 es\n\nuniform mat4 uModel;\nuniform mat4 uView;\nuniform mat4 uProjection;\n\nuniform float uObjectId;\n\nin vec4 aPosition;\nin vec3 aNormal;\nin vec4 aColor;\nin float aSurfaceId;\n\nout vec4 vColor;\n\nvec3 hashId (float id)\n{\nfloat r = fract(mod(id * 25738.32498, 456.221));\nfloat g = fract(mod(id * 565612.08321, 123.1231));\nfloat b = fract(mod(id * 98281.32498, 13.221));\nreturn vec3(r, g, b);\n}\n\nvoid main()\n{\nmat4 modelView = uView * uModel;\ngl_Position = uProjection * uView * uModel * aPosition;\n\n\nvec3 vertexColor = aColor.rgb;\nvec3 localNormal = aNormal.rgb * 0.5 + 0.5;\nvec3 surfaceId = hashId(uObjectId + aSurfaceId);\n\nvColor.a = 1.0;\nvColor = aColor;\n}"
  }
};
