var gum=function(exports){"use strict";function clamp(x,min=0,max=1){return Math.min(Math.max(x,min),max)}function lerp(a,b,fac=.5){fac=clamp(fac);return b*fac+(1-fac)*a}function remap(x,min,max,outMin=0,outMax=1){return clamp((x-min)/(max-min))*(outMax-outMin)+outMin}function random(a=1,b){if(b===undefined){b=a;a=0}return a+Math.random()*(b-a)}function degrees(radians){return 180*radians/Math.PI}function radians(degrees){return Math.PI*degrees/180}function generateId(){let id="";for(let i=0;i<4;i++){id+=Math.floor(Math.random()*10)}return id}var common=Object.freeze({__proto__:null,clamp:clamp,degrees:degrees,generateId:generateId,lerp:lerp,radians:radians,random:random,remap:remap});function select(tag){if(tag instanceof HTMLElement){return tag}const elem=document.querySelector(tag);if(!elem){return false}return elem}function tag(string,styleObject){const tag=string.split(/#|\./)[0].trim();const elem=document.createElement(tag);const idRegEx=/#(\w|-)+/g;const id=string.match(idRegEx);if(id){elem.id=id[0].replace("#","")}const classRegEx=/\.(\w|-)+/g;const classList=string.match(classRegEx);if(classList){classList.forEach((x=>elem.classList.add(x.replace(".",""))))}if(styleObject){style(elem,styleObject)}return elem}function style(elem,styleObject){for(const property in styleObject){elem.style[property]=styleObject[property]}}var dom=Object.freeze({__proto__:null,select:select,style:style,tag:tag});const ColorDict={hermosapink:"#ffb3f0",corinthianpink:"#ffa6d9",cameopink:"#e6adcf",fawn:"#d1b0b3",lightbrowndrab:"#b08699",coralred:"#ff7399",freshcolor:"#ff788c",grenadinepink:"#ff616b",eosinepink:"#ff5ec4",spinelred:"#ff4dc9",oldrose:"#d94d99",eugeniareda:"#ed3d66",eugeniaredb:"#e62e73",rawsienna:"#b85e00",vinaceoustawny:"#c74300",jasperred:"#fa2b00",spectrumred:"#f20000",redorange:"#e81900",etruscanred:"#c9303e",burntsienna:"#a93400",ochrered:"#a7374b",scarlet:"#d50c42",carmine:"#d60036",indianlake:"#cc1a97",rosolancpurple:"#b319ab",pomegranitepurple:"#b90078",hydrangeared:"#9e194d",brickred:"#a32100",carminered:"#a10b2b",pompeianred:"#a90636",red:"#a10045",brown:"#6c2b11",haysrusset:"#681916",vandykered:"#740909",pansypurple:"#6f0043",paleburntlake:"#730f1f",violetred:"#3d0079",vistorislake:"#5c2c45",sulpheryellow:"#f5f5b8",palelemonyellow:"#fff59e",naplesyellow:"#faed8f",ivorybuff:"#ebd999",seashellpink:"#ffcfc4",lightpinkishcinnamon:"#ffbf99",pinkishcinnamon:"#f2ad78",cinnamonbuff:"#ffbf6e",creamyellow:"#ffb852",goldenyellow:"#fa9442",vinaceouscinnamon:"#f59994",ochraceoussalmon:"#d99e73",isabellacolor:"#c3a55c",maple:"#c2975a",olivebuff:"#bcd382",ecru:"#c0b490",yellow:"#ffff00",lemonyellow:"#f2ff26",apricotyellow:"#ffe600",pyriteyellow:"#c4bf33",oliveocher:"#d1bd19",yellowocher:"#e0b81f",orangeyellow:"#ffab00",yelloworange:"#ff8c00",apricotorange:"#ff7340",orange:"#ff5200",peachred:"#ff3319",englishred:"#de4500",cinnamonrufous:"#c2612c",orangerufous:"#c05200",sulphineyellow:"#baa600",khaki:"#b68400",citronyellow:"#a6d40d",buffycitrine:"#888d2a",darkcitrine:"#7e8743",lightgrayisholive:"#76844e",krongbergsgreen:"#759243",olive:"#718600",orangecitrine:"#8c6510",sudanbrown:"#9b5348",olivegreen:"#58771e",lightbrownisholive:"#706934",deepgrayisholive:"#505423",palerawumber:"#5e4017",sepia:"#503d00",madderbrown:"#651300",marsbrowntobacco:"#522000",vandykebrown:"#362304",turquoisegreen:"#b5ffc2",glaucousgreen:"#b3e8c2",darkgreenishglaucous:"#b3d9a3",yellowgreen:"#a6ff47",lightgreenyellow:"#bdf226",nightgreen:"#7aff00",oliveyellow:"#99b333",artemesiagreen:"#65a98f",andovergreen:"#5c8a73",rainettegreen:"#85b857",pistachiogreen:"#56aa69",seagreen:"#33ff7d",benzolgreen:"#00d973",lightporcelaingreen:"#23c17c",green:"#40c945",dullviridiangreen:"#19cc33",oilgreen:"#6ea900",diaminegreen:"#1b8e13",cossackgreen:"#328e13",lincolngreen:"#405416",blackisholive:"#324e2a",deepslateolive:"#172713",nileblue:"#bfffe6",palekingsblue:"#abf5ed",lightglaucousblue:"#a6e6db",salviablue:"#96bfe6",cobaltgreen:"#94ff94",calamineblue:"#80ffcc",venicegreen:"#6bffb3",cerulianblue:"#29bdad",peacockblue:"#00cf91",greenblue:"#2dbc94",olympicblue:"#4f8fe6",blue:"#0d75ff",antwarpblue:"#008aa1",helvetiablue:"#0057ba",darkmediciblue:"#417777",duskygreen:"#00592e",deeplyonsblue:"#0024cc",violetblue:"#202d85",vandarpoelsblue:"#003e83",darktyrianblue:"#0d2b52",dullvioletblack:"#06004f",deepindigo:"#000831",deepslategreen:"#0f261f",grayishlavendera:"#b8b8ff",grayishlavenderb:"#bfabcc",laeliapink:"#cc85d1",lilac:"#b875eb",eupatoriumpurple:"#bf36e0",lightmauve:"#9161f2",aconiteviolet:"#9c52f2",dullblueviolet:"#6e66d4",darksoftviolet:"#4d52de",blueviolet:"#4733ff",purpledrab:"#754260",deepvioletplumbeous:"#5c7287",veroniapurple:"#7e3075",darkslatepurple:"#53225c",taupebrown:"#6b2e63",violetcarmine:"#531745",violet:"#2619d1",redviolet:"#3400a3",cotingapurple:"#340059",duskymadderviolet:"#2d0060",white:"#ffffff",neutralgray:"#b5d1cc",mineralgray:"#9fc2b2",warmgray:"#9cb29e",slatecolor:"#1b3644",black:"#000000"};const containerStyle={display:"flex",position:"fixed",width:"100%",backgroundColor:"rgba(0,0,0,0.25)",bottom:0,left:0,zIndex:10};const swatchStyle={width:"24px",height:"24px"};function ColorSwatch(color){let container=select("#swatches");if(!container){container=tag("div#swatches",containerStyle);document.body.append(container)}const swatch=tag("div.swatch",swatchStyle);style(swatch,{backgroundColor:color});container.append(swatch);return swatch}const defR=0;const defG=0;const defB=0;const defA=1;class Color{constructor(r,g,b,a){this._r=r??defR;this._g=g??defG;this._b=b??defB;this._a=a??defA;this._hsl=rgbToHsl(this._r,this._g,this._b);ColorSwatch(this.rgbString())}get r(){return this._r}get g(){return this._g}get b(){return this._b}get a(){return this._a}get rgb(){return[this._r,this._g,this._b]}get rgba(){return[this._r,this._g,this._b,this._a]}get h(){return this._hsl[0]}get s(){return this._hsl[1]}get l(){return this._hsl[2]}get hsl(){return this._hsl}get hsla(){return[...this._hsl,this._a]}rgbString(){const r255=Math.round(this._r*255);const g255=Math.round(this._g*255);const b255=Math.round(this._b*255);if(this._a===1){return`rgb(${r255}, ${g255}, ${b255})`}return`rgba(${r255}, ${g255}, ${b255}, this._a)`}hslString(){const h360=Math.round(this.h);const s100=Math.round(this.s*100);const l100=Math.round(this.s*100);if(this._a===1){return`hsl(${h360}, ${s100}, ${l100})`}return`hsla(${h360}, ${s100}, ${l100}, this._a)`}blend(other,amt=.5,mode="RGB"){return blend(this,other,amt,mode)}}function color(...args){if(validColorArray(args)){return new Color(...args)}if(validColorArray(args[0])){return new Color(...args[0])}let col=args[0];if(col instanceof Color){return new Color(col.r,col.g,col.g,col.a)}if(ColorDict[col]){col=ColorDict[col]}switch(colorFormat(col)){case"HEX":return new Color(...hexToRgb(col,true));case"RGB":return new Color(...strToRgb(col,true));case"HSL":return new Color(hslToRgb(...strToHsl(col,true)))}return new Color(Math.random(),Math.random(),Math.random())}function validColorArray(arr){if(Array.isArray(arr)&&arr.length>=3){return arr.every((x=>x!==""&&!isNaN(Number(x))))}return false}function colorFormat(str){if(str.indexOf("#")===0){return"HEX"}else if(str.indexOf("rgb")===0){return"RGB"}else if(str.indexOf("hsl")===0){return"HSL"}}function extractNumbers(str){const parts=str.replace(/[^0-9|\.]+/g,"-").split("-");const numbers=[];for(let part of parts){if(part==="")continue;const n=Number(part);if(!isNaN(n))numbers.push(n)}return numbers}function strToRgb(str,normalized=true){if(str.indexOf("rgb")===-1){return[defR,defG,defB]}const numbers=extractNumbers(str);if(numbers.length<3){return[defR,defG,defB]}const m=normalized?1/255:1;const color=[numbers[0]*m,numbers[1]*m,numbers[2]*m];if(numbers[3]!==undefined){color.push(numbers[3])}return color}function strToHsl(str,normalized=true){if(str.indexOf("hsl")===-1){return[0,0,0]}const numbers=extractNumbers(str);if(numbers.length<3){return[0,0,0]}const m=normalized?1/100:1;const color=[numbers[0],numbers[1]*m,numbers[2]*m];if(numbers[3]!==undefined){color.push(numbers[3])}return color}function hexToRgb(hex,normalized=true){const h=hex.slice(1);const m=normalized?1/255:1;const parse=v=>m*parseInt(v,16);if(h.length===3){return[parse(h[0]+h[0]),parse(h[1]+h[1]),parse(h[2]+h[2])]}if(h.length===6){return[parse(h[0]+h[1]),parse(h[2]+h[3]),parse(h[4]+h[5])]}if(h.length===8){return[parse(h[0]+h[1]),parse(h[2]+h[3]),parse(h[4]+h[5]),parse(h[6]+h[7])]}return[defR,defG,defB]}function hslToRgb(h=0,s=0,l=0,a=1){h=(h+360)%360;s=Math.max(Math.min(s,1),0);l=Math.max(Math.min(l,1),0);const c=(1-Math.abs(2*l-1))*s;const h1=h/60;const x=c*(1-Math.abs(h1%2-1));let r,g,b;if(h1<1){r=c;g=x;b=0}else if(h1<2){r=x;g=c;b=0}else if(h1<3){r=0;g=c;b=x}else if(h1<4){r=0;g=x;b=c}else if(h1<5){r=x;g=0;b=c}else if(h1<=6){r=c;g=0;b=x}const m=l-c/2;return[r+m,g+m,b+m,a]}function rgbToHsl(r=0,g=0,b=0,a=1){r=Math.min(Math.max(r,0),1);g=Math.min(Math.max(g,0),1);b=Math.min(Math.max(b,0),1);const xMax=Math.max(r,g,b);const xMin=Math.min(r,g,b);const v=xMax;const c=xMax-xMin;const l=(xMax+xMin)/2;let h=0;if(c===0){h=0}else if(v===r){h=60*(0+(g-b)/c)}else if(v===g){h=60*(2+(b-r)/c)}else if(v===b){h=60*(4+(r-g)/c)}let s=0;if(l>0&&l<1){s=(v-l)/Math.min(l,1-l)}return[h,s,l,a]}function isColor(any){return any instanceof Color}function blend(src,target,amt=.5,mode="RGB"){switch(mode.toUpperCase()){case"RGB":return blendRGB_(src,target,amt);case"HSL":return blendHSL_(src,target,amt)}}function blendRGB_(src,target,amt=.5){if(!isColor(src)||!isColor(target)){return new Color}amt*=target.a;const r=lerp(src.r,target.r,amt);const g=lerp(src.g,target.g,amt);const b=lerp(src.b,target.b,amt);return new Color(r,g,b,src.a)}function blendHSL_(src,target,amt=.5){if(!isColor(src)||!isColor(target)){return new Color}amt*=target.a;const h=lerp(src.h,target.h,amt);const s=lerp(src.s,target.s,amt);const l=lerp(src.l,target.l,amt);return new Color(...hslToRgb(h,s,l,src.a))}window.Color=Color;const shaders={default:{frag:"#version 300 es\n\nprecision mediump float;\n\nin vec4 vColor;\nout vec4 fragColor;\n\nvoid main() {\n  fragColor = vec4(vColor.rgb, 1.0);\n}",vert:"#version 300 es\n\nuniform mat4 uModel;\nuniform mat4 uView;\nuniform mat4 uProjection;\n\nin vec4 aPosition;\nin vec4 aColor;\n\nout vec4 vColor;\n\n\nvoid main() \n{\n  mat4 modelView = uView * uModel;\n  gl_Position = uProjection * uView * uModel * aPosition;\n  vColor = aColor;\n}"},geo:{frag:"#version 300 es\n\nprecision mediump float;\n\nuniform vec3 uEye;\nuniform vec4 uColor;\n\nin vec4 vWorldPosition;\nin vec4 vColor;\nin vec3 vWorldNormal;\nin vec3 vViewNormal;\nin vec3 vSurfaceId;\nin float vDepth;\nin float vId;\n\nout vec4 fragColor;\n\nvoid main() {\n  vec3 lightDir = normalize(vec3(3.0, 4.0, 2.0));\n  float nDotL = clamp(dot(vWorldNormal, lightDir), 0.0, 1.0);\n  float light = clamp(smoothstep(0.1, 0.4, nDotL) + 0.8, 0.0, 1.0);\n  float nDotV = dot(vViewNormal, vec3(0.0, 0.0, 1.0));\n\n  fragColor = vec4(vId, nDotV, nDotL, 1.0);\n\n  fragColor = vec4(vViewNormal * 0.5 + 0.5, 1.0);\n  fragColor = vec4(vSurfaceId, 1.0);\n}",vert:"#version 300 es\n\nuniform mat4 uModel;\nuniform mat4 uView;\nuniform mat4 uProjection;\nuniform float uNear;\nuniform float uFar;\nuniform float uObjectId;\n\nin vec4 aPosition;\nin vec4 aColor;\n\nin vec4 aNormal;\nin float aSurfaceId;\n\nout vec4 vWorldPosition;\nout vec4 vColor;\nout vec3 vWorldNormal;\nout vec3 vViewNormal;\nout vec3 vSurfaceId;\nout float vDepth;\nout float vId;\n\n/**\n *\n */\nvec3 hashId(float id) {\n  float r = fract(mod(id * 25738.32498, 456.221));\n  float g = fract(mod(id * 565612.08321, 123.1231));\n  float b = fract(mod(id * 98281.32498, 13.221));\n  return vec3(r, g, b);\n}\n\n/**\n *\n */\nvoid main() {\n  gl_PointSize = 4.0;\n  mat4 modelView = uView * uModel;\n  mat3 normMatrix = transpose(inverse(mat3(modelView)));\n  vViewNormal = normalize(normMatrix * aNormal.xyz);\n  vWorldNormal = normalize(mat3(uModel) * aNormal.xyz);\n  vColor = aColor;\n\n  gl_Position = uProjection * uView * uModel * aPosition;\n\n  vec3 rounded = round(gl_Position.xyz * 10.0) / 10.0;\n  // gl_Position.xyz = rounded;\n\n  float id = mod(aSurfaceId + uObjectId, 255.0);\n  vId = id / 255.0 + (1.0 / 255.0);\n\n  vSurfaceId = hashId(aSurfaceId + uObjectId);\n\n  vWorldPosition = gl_Position;\n}"},"post-chromatic":{frag:"#version 300 es\n\nprecision mediump float;\n\nuniform sampler2D uMainTex;\nuniform sampler2D uDepthTex;\nuniform vec2 uTexSize;\nuniform float uNear;\nuniform float uFar;\n\n\nin vec2 vTexCoord;\nout vec4 fragColor;\n\n\nvoid main() {\n  vec2 rOff = vec2(0.0, 4.0);\n  vec2 gOff = vec2(0.0, 0.0);\n  vec2 bOff = vec2(4.0, 0.0);\n  vec2 pixelSize = 1.0 / uTexSize;\n  vec4 col = texture(uMainTex, vTexCoord);\n\n  fragColor = col;\n  float r = texture(uMainTex, vTexCoord + (pixelSize * rOff)).r;\n  float g = texture(uMainTex, vTexCoord + (pixelSize * gOff)).g;\n  float b = texture(uMainTex, vTexCoord + (pixelSize * bOff)).b;\n\n  fragColor.rgb = vec3(r, g, b);\n\n  // vec2 uv = vTexCoord;\n  // uv *= 1.0 - uv.xy;\n\n  // float vig = uv.x * uv.y * 15.0;\n\n  // vig = pow(vig, 0.03);\n\n  // fragColor.rgb *= vig;\n}"},"post-outline":{frag:"#version 300 es\n\nprecision mediump float;\n\nuniform sampler2D uMainTex;\nuniform sampler2D uDepthTex;\nuniform vec2 uTexSize;\nuniform float uNear;\nuniform float uFar;\n\nin vec2 vTexCoord;\nout vec4 fragColor;\n\nfloat linearDepth(float d, float near, float far) {\n  float z = d * 2.0 - 1.0;\n  return (2.0 * near * far) / (far + near - d * (far - near)) / far;\n}\n\nvec4 gradient(sampler2D tex, vec2 coord) {\n  vec2 offset = vec2(1.0, 1.0) / uTexSize;\n\n  vec4 xSum = vec4(0.0);\n  vec4 ySum = vec4(0.0);\n\n  xSum += texture(tex, coord + vec2(-offset.x, 0.0)) * -1.0;\n  xSum += texture(tex, coord + vec2(+offset.x, 0.0));\n\n  ySum += texture(tex, coord + vec2(0.0, -offset.y)) * -1.0;\n  ySum += texture(tex, coord + vec2(0.0, +offset.y));\n\n  return sqrt(xSum * xSum + ySum * ySum);\n}\n\nvoid main() {\n  vec4 col = texture(uMainTex, vTexCoord);\n  float depth = texture(uDepthTex, vTexCoord).r;\n  float lDepth = linearDepth(depth, uNear, uFar);\n\n  vec4 colGrad = gradient(uMainTex, vTexCoord);\n  vec4 depthGrad = gradient(uDepthTex, vTexCoord);\n\n  float idQ = mix(colGrad.r, 0.0, smoothstep(0.0, 0.3, lDepth));\n\n  float idEdge = step(0.0001, colGrad.x);\n\n  float depthQ = mix(0.0, 100.0, smoothstep(0.0, 0.01, col.g));\n\n  float depthEdge = step(0.01, depthGrad.r);\n\n  float normEdge = step(0.3, colGrad.g);\n\n  float edge = max(idEdge, depthEdge);\n\n  vec3 grad = vec3(idEdge, depthEdge, 0.0);\n\n  float fog = smoothstep(4.0, 40.0, lDepth * (uFar - uNear));\n\n  // float surfaceId = round(col.r * 20.0);\n  fragColor.rgb = mix(vec3(0.2, 0.2, 0.2), vec3(0.6, 0.5, 0.5), 1.0 - fog);\n  // fragColor.rgb *= 1.0 - ((1.0 - fog) * edge);\n  // fragColor.a = 1.0;\n\n  fragColor = vec4(vec3(edge * 0.4 + 0.1), 1.0);\n\n  // fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n\n  // fragColor = vec4(mix(vec3(1.0, 1.0, 0.2), vec3(0.1, 0.1, 0.1), edge), 1.0);\n\n  // fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n  // fragColor = vec4(vec3(idEdge), 1.0);\n  // fragColor = vec4(colGrad.ggg, 1.0);\n  // fragColor = vec4(1.0, 0.0, 1.0, 1.0);\n  // fragColor = vec4(vec3(fog), 1.0);\n\n}"},post:{vert:"#version 300 es\n\nin vec2 aPosition;\nout vec2 vTexCoord;\n\nvoid main() {\n  vTexCoord = (aPosition + 1.0) / 2.0;\n  gl_Position = vec4(aPosition, 0.0, 1.0);\n}"},textured:{frag:"#version 300 es\n\nprecision mediump float;\n\nuniform sampler2D uTex;\n\nin vec4 vColor;\nin vec2 vTexCoord;\nout vec4 fragColor;\n\nvoid main() {\n  fragColor.rg = vTexCoord;\n  fragColor.a = 1.0;\n\n  fragColor = texture(uTex, vTexCoord);\n}",vert:"#version 300 es\n\nuniform mat4 uModel;\nuniform mat4 uView;\nuniform mat4 uProjection;\n\nuniform float uObjectId;\n\nin vec4 aPosition;\nin vec3 aNormal;\nin vec2 aTexCoord;\nin vec4 aColor;\nin float aSurfaceId;\n\nout vec4 vColor;\nout vec2 vTexCoord;\n\nvec3 hashId(float id) {\n  float r = fract(mod(id * 25738.32498, 456.221));\n  float g = fract(mod(id * 565612.08321, 123.1231));\n  float b = fract(mod(id * 98281.32498, 13.221));\n  return vec3(r, g, b);\n}\n\nvoid main() {\n  mat4 modelView = uView * uModel;\n  gl_Position = uProjection * uView * uModel * aPosition;\n  vColor = aColor;\n  vTexCoord = aTexCoord;\n}"},unlit:{frag:"#version 300 es\n\nprecision mediump float;\n\nin vec4 vColor;\nout vec4 fragColor;\n\nvoid main() {\n  fragColor = vec4(vColor.rgb, 1.0);\n}",vert:"#version 300 es\n\nuniform mat4 uModel;\nuniform mat4 uView;\nuniform mat4 uProjection;\n\nuniform float uObjectId;\n\nin vec4 aPosition;\nin vec3 aNormal;\nin vec4 aColor;\nin float aSurfaceId;\n\nout vec4 vColor;\n\nvec3 hashId (float id) \n{\n  float r = fract(mod(id * 25738.32498, 456.221));\n  float g = fract(mod(id * 565612.08321, 123.1231));\n  float b = fract(mod(id * 98281.32498, 13.221));\n  return vec3(r, g, b);\n}\n\nvoid main() \n{\n  mat4 modelView = uView * uModel;\n  gl_Position = uProjection * uView * uModel * aPosition;\n  \n\n  vec3 vertexColor = aColor.rgb;\n  vec3 localNormal = aNormal.rgb * 0.5 + 0.5;\n  vec3 surfaceId = hashId(uObjectId + aSurfaceId);\n\n  vColor.a = 1.0;\n  vColor.rgb = vertexColor;\n}"}};class Vec2{constructor(x,y,z){this._x=x||0;this._y=y||0;this._changed=false}get x(){return this._x}set x(val){this._x=val;this._changed=true}get y(){return this._y}set y(val){this._y=val;this._changed=true}get xy(){return[this.x,this.y]}set xy(xy){this.set(...xy)}changed(){if(this._changed){this._changed=false;return true}return false}set(x,y){this._x=x;this._y=y;this._changed=true;return this}copy(){return new Vec2(...this.xy)}add(a){this.x+=a.x;this.y+=a.y;return this}distance(a){const dx=this.y-a.x;const dy=this.y-a.y;return Math.sqrt(dx*dx+dy*dy)}distance2(a){const dx=this.y-a.x;const dy=this.y-a.y;return dx*dx+dy*dy}}class Vec3{constructor(x,y,z){this._x=x||0;this._y=y||0;this._z=z||0;this._changed=false}get x(){return this._x}set x(val){this._x=val;this._changed=true}get y(){return this._y}set y(val){this._y=val;this._changed=true}get z(){return this._z}set z(val){this._z=val;this._changed=true}get xyz(){return[this.x,this.y,this.z]}set xyz(xyz){this.set(...xyz)}changed(){if(this._changed){this._changed=false;return true}return false}set(x,y,z){this._x=x;this._y=y;this._z=z;this._changed=true;return this}copy(){return new Vec3(...this.xyz)}add(a){this.x+=a.x;this.y+=a.y;this.z+=a.z;return this}sub(a){this.x-=a.x;this.y-=a.y;this.z-=a.z;return this}distance(a){const dx=this.y-a.x;const dy=this.y-a.y;const dz=this.z-a.z;return Math.sqrt(dx*dx+dy*dy+dz*dz)}distance2(a){const dx=this.y-a.x;const dy=this.y-a.y;const dz=this.z-a.z;return dx*dx+dy*dy+dz*dz}mag(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}mult(s){this.x*=s;this.y*=s;this.z*=s;return this}div(s){return this.mult(1/s)}normalize(len=1){const mag=this.mag();if(mag===0){return this}let scalar=len/mag;this.x*=scalar;this.y*=scalar;this.z*=scalar;return this}dot(a){return this.x*a.x+this.y*a.y+this.z*a.z}cross(a){const x=this.y*a.z-this.z*a.y;const y=this.z*a.x-this.x*a.z;const z=this.x*a.y-this.y*a.x;return new Vec3(x,y,z)}equals(a,tolerance=Number.EPSILON){return Math.abs(this.x-a.x)<tolerance&&Math.abs(this.y-a.y)<tolerance&&Math.abs(this.z-a.z)<tolerance}}function triangulate(faces){const outFaces=[];faces.forEach((face=>{if(face.length<3){return}if(face.length===3){outFaces.push(face);return}for(let i=1;i<face.length-1;i++){outFaces.push([face[0],face[i],face[i+1]])}}));return outFaces}function validate(vertices,faces){for(let f=0;f<faces.length;f++){const face=faces[f];for(let vi=0;vi<face.length;vi++){if(face[vi]>vertices.length){return false}}}return true}function findGroups(faces){let groups=[];const join=(a,b)=>{if(b instanceof Set){for(let val of b.values()){a.add(val)}return}b.forEach((val=>a.add(val)))};for(let fi=0;fi<faces.length;fi++){const vertices=faces[fi];for(let vi=0;vi<vertices.length;vi++){const v=vertices[vi];let markedGroups=[];for(let gi=0;gi<groups.length;gi++){const group=groups[gi];if(group.has(v)){join(group,vertices);markedGroups.push(gi)}}if(markedGroups.length===0){const newGroup=new Set;join(newGroup,vertices);groups.push(newGroup)}if(markedGroups.length>1){const receivingGroup=groups[markedGroups[0]];for(let mgi=1;mgi<markedGroups.length;mgi++){join(receivingGroup,groups[markedGroups[mgi]]);groups[markedGroups[mgi]]=false}groups=groups.filter((x=>x))}}}const groupsByVertIndex=[];groups.forEach(((group,groupIndex)=>{for(let vertIndex of group.values()){groupsByVertIndex[vertIndex]=groupIndex}}));return groupsByVertIndex}function applyAttribVarying(attribName,attribValues,vertices){const outVertices=[];if(vertices.length!==attribValues.length){console.error(`Cannot apply attribute: ${attribName} Mismatched length.`);return vertices}for(let vi=0;vi<vertices.length;vi++){const vertex=vertices[vi];const outVertex={};for(let attrib in vertex){outVertex[attrib]=[...vertex[attrib]]}if(Array.isArray(attribValues[vi])){outVertex[attribName]=[...attribValues[vi]]}else{outVertex[attribName]=[attribValues[vi]]}outVertices.push(outVertex)}return outVertices}function applyAttribConstant(attribName,attribValue,vertices){const outVertices=[];for(let vi=0;vi<vertices.length;vi++){const vertex=vertices[vi];const outVertex={};for(let attrib in vertex){outVertex[attrib]=[...vertex[attrib]]}if(Array.isArray(attribValue)){outVertex[attribName]=[...attribValue]}else{outVertex[attribName]=[attribValue]}outVertices.push(outVertex)}return outVertices}function facesToEdges(faces){const outEdges=[];for(let fi=0;fi<faces.length;fi++){const face=faces[fi];for(let vi=0;vi<face.length;vi++){outEdges.push([face[vi],face[(vi+1)%face.length]])}}return outEdges}function verticesToNormals(vertices){const outEdges=[];for(let vi=0;vi<vertices.length;vi++){const vertex=vertices[vi];if(!vertex.position||!vertex.normal){continue}const{position:position,normal:normal}=vertex;const position2=new Vec3(...position);position2.add(new Vec3(...normal).normalize(1));outEdges.push(vertex);const vertex2={...vertex,position:position2};outEdges.push(vertex2)}console.log(outEdges);return outEdges}var meshOps=Object.freeze({__proto__:null,applyAttribConstant:applyAttribConstant,applyAttribVarying:applyAttribVarying,facesToEdges:facesToEdges,findGroups:findGroups,triangulate:triangulate,validate:validate,verticesToNormals:verticesToNormals});class Mesh{constructor(vertices,faces,meta={}){this.vertices=vertices;this.faces=faces;this.name=meta.name||"mesh"}triangulate(){this.faces=triangulate(this.faces);return this}render(){const mode="TRIANGLES";const triangles=triangulate(this.faces);const vertexCount=triangles.length*3;const attribs={};for(let f=0;f<triangles.length;f++){const face=triangles[f];for(let v=0;v<3;v++){const vertex=this.vertices[face[v]];for(let attrib in vertex){const data=vertex[attrib];if(!attribs[attrib]){attribs[attrib]=[]}attribs[attrib].push(...data)}}}for(let attrib in attribs){attribs[attrib]=new Float32Array(attribs[attrib])}const name=this.name;return{mode:mode,vertexCount:vertexCount,attribs:attribs,name:name}}renderEdges(){const mode="LINES";const edges=facesToEdges(this.faces);const vertexCount=edges.length*2;const attribs={};for(let ei=0;ei<edges.length;ei++){const edge=edges[ei];for(let vi=0;vi<2;vi++){const vertex=this.vertices[edge[vi]];for(let attrib in vertex){const data=vertex[attrib];if(!attribs[attrib]){attribs[attrib]=[]}attribs[attrib].push(...data)}}}for(let attrib in attribs){attribs[attrib]=new Float32Array(attribs[attrib])}const name=this.name+"_edges";return{mode:mode,vertexCount:vertexCount,attribs:attribs,name:name}}renderPoints(){const mode="POINTS";const vertexCount=this.vertices.length;const attribs={};for(let vi=0;vi<this.vertices.length;vi++){const vertex=this.vertices[vi];for(let attrib in vertex){const data=vertex[attrib];if(!attribs[attrib]){attribs[attrib]=[]}attribs[attrib].push(...data)}}for(let attrib in attribs){attribs[attrib]=new Float32Array(attribs[attrib])}const name=this.name+"_points";return{mode:mode,vertexCount:vertexCount,attribs:attribs,name:name}}renderNormals(length=.05){const mode="LINES";const vertexCount=this.vertices.length*2;const attribs={};for(let vi=0;vi<this.vertices.length;vi++){const vertex=this.vertices[vi];for(let attrib in vertex){const data=vertex[attrib];if(!attribs[attrib]){attribs[attrib]=[]}attribs[attrib].push(...data);if(attrib==="position"&&vertex["normal"]){const{position:position,normal:normal}=vertex;const position2=new Vec3(...position);position2.add(new Vec3(...normal).normalize(length));attribs[attrib].push(...position2.xyz)}else{attribs[attrib].push(...data)}}}for(let attrib in attribs){attribs[attrib]=new Float32Array(attribs[attrib])}const name=this.name+"_normals";return{mode:mode,vertexCount:vertexCount,attribs:attribs,name:name}}findGroups(){const groups=findGroups(this.faces);this.vertices=applyAttribVarying("surfaceId",groups,this.vertices);return this}fill(col){this.vertices=applyAttribConstant("color",col.rgba,this.vertices);return this}}function cube(size=1){const s=size/2;const positions=[[-s,-s,+s],[+s,-s,+s],[+s,-s,-s],[-s,-s,-s],[-s,+s,+s],[+s,+s,+s],[+s,+s,-s],[-s,+s,-s]];const vertices=[];const faces=[];let i=0;const quad=function(a,b,c,d,normal,color){vertices.push({position:positions[a],normal:normal,color:color,texCoord:[0,0]},{position:positions[b],normal:normal,color:color,texCoord:[1,0]},{position:positions[c],normal:normal,color:color,texCoord:[1,1]},{position:positions[d],normal:normal,color:color,texCoord:[0,1]});faces.push([i,i+1,i+2,i+3]);i+=4};quad(0,1,5,4,[0,0,+1],[1,0,0,1]);quad(2,3,7,6,[0,0,-1],[0,1,1,1]);quad(4,5,6,7,[0,+1,0],[1,0,1,1]);quad(1,0,3,2,[0,-1,0],[0,1,0,1]);quad(3,0,4,7,[-1,0,0],[0,0,1,1]);quad(1,2,6,5,[+1,0,0],[1,1,0,1]);let mesh=new Mesh(vertices,faces,{name:"cube"});return mesh}function icosphere(size=1,level=1,flat=false){const radius=size/2;const t=(1+Math.sqrt(5))/2;let positions=[new Vec3(-t,0,-1).normalize(radius),new Vec3(+t,0,-1).normalize(radius),new Vec3(+t,0,+1).normalize(radius),new Vec3(-t,0,+1).normalize(radius),new Vec3(-1,-t,0).normalize(radius),new Vec3(+1,-t,0).normalize(radius),new Vec3(+1,+t,0).normalize(radius),new Vec3(-1,+t,0).normalize(radius),new Vec3(0,-1,-t).normalize(radius),new Vec3(0,-1,+t).normalize(radius),new Vec3(0,+1,+t).normalize(radius),new Vec3(0,+1,-t).normalize(radius)];let faces=[[0,3,7],[0,7,11],[0,11,8],[0,8,4],[0,4,3],[2,1,6],[2,6,10],[2,10,9],[2,9,5],[2,5,1],[3,9,10],[3,10,7],[3,4,9],[1,8,11],[1,11,6],[1,5,8],[8,5,4],[9,4,5],[10,6,7],[11,7,6]];const addPosition=pos=>{positions.push(pos.normalize(radius))};const foundMidPoints={};const getMidPoint=(a,b)=>{const key=a<b?`${a}_${b}`:`${b}_${a}`;if(foundMidPoints[key]){return foundMidPoints[key]}const posA=positions[a].copy();const posB=positions[b].copy();const midPoint=posA.copy().add(posB).div(2);addPosition(midPoint);const index=positions.length-1;foundMidPoints[key]=index;return index};let faceBuffer=[];let vertices=[];for(let i=0;i<level;i++){faceBuffer=[];for(const face of faces){const a=getMidPoint(face[0],face[1]);const b=getMidPoint(face[1],face[2]);const c=getMidPoint(face[2],face[0]);faceBuffer.push([face[0],a,c]);faceBuffer.push([face[1],b,a]);faceBuffer.push([face[2],c,b]);faceBuffer.push([a,b,c])}faces=faceBuffer}if(flat){faceBuffer=[];for(const face of faces){const a=positions[face[0]];const b=positions[face[1]];const c=positions[face[2]];const ba=b.copy().sub(a);const ca=c.copy().sub(a);const normal=ba.cross(ca).normalize();const pointer=vertices.length;vertices.push({position:a.xyz,normal:normal.xyz},{position:b.xyz,normal:normal.xyz},{position:c.xyz,normal:normal.xyz});faceBuffer.push([pointer,pointer+1,pointer+2])}faces=faceBuffer}else{vertices=positions.map((pos=>({position:pos.xyz,normal:pos.normalize().xyz})))}return new Mesh(vertices,faces,{name:"icosphere"})}function quad(size){const s=size/2;const positions=[new Vec3(-s,0,-s),new Vec3(+s,0,-s),new Vec3(+s,0,+s),new Vec3(-s,0,+s)];const faces=[[0,3,2,1]];const vertices=positions.map((pos=>({position:pos.xyz,normal:[0,1,0]})));return new Mesh(vertices,faces,{name:"quad"})}function grid(size,subdivisions=10,flat=false){const s=size/2;const step=size/(subdivisions+1);const positions=[];const faces=[];if(flat){let vertIndex=0;for(let i=0;i<subdivisions+1;i++){const z=i*step;for(let j=0;j<subdivisions+1;j++){const x=j*step;positions.push([-s+x,0,-s+z]);positions.push([-s+x+step,0,-s+z]);positions.push([-s+x+step,0,-s+z+step]);positions.push([-s+x,0,-s+z+step]);faces.push([vertIndex,vertIndex+3,vertIndex+2,vertIndex+1]);vertIndex+=4}}}else{for(let i=0;i<subdivisions+2;i++){const z=i*step;for(let j=0;j<subdivisions+2;j++){const x=j*step;positions.push([-s+x,0,-s+z]);if(i<subdivisions+1&&j<subdivisions+1){const a=i*(subdivisions+2)+j;const b=a+1;const c=a+subdivisions+2;const d=c+1;faces.push([a,c,d,b])}}}}const vertices=positions.map((pos=>({position:pos,normal:[0,1,0]})));return new Mesh(vertices,faces,{name:"grid"})}function circle(size,resolution=12,fill="ngon"){const positions=[];const faces=[];if(fill==="fan"){positions.push([0,0,0])}else if(fill==="ngon"){faces[0]=[]}for(let i=0;i<resolution;i++){const theta=-i*Math.PI*2/resolution;const x=Math.cos(theta)*(size/2);const z=Math.sin(theta)*(size/2);positions.push([x,0,z]);if(fill==="fan"){const next=(i+1)%resolution;faces.push([0,i+1,next+1])}else if(fill==="ngon"){faces[0].push(i)}}const vertices=positions.map((pos=>({position:pos,normal:[0,1,0]})));return new Mesh(vertices,faces,{name:"circle"})}function _fsQuad(){const vertices=[[-1,-1,0],[+1,-1,0],[-1,+1,0],[-1,+1,0],[+1,-1,0],[+1,+1,0]];return{mode:"TRIANGLES",vertexCount:6,attribs:{aPosition:new Float32Array(vertices.flat())}}}function _axes(){const positions=[[0,0,0],[1,0,0],[0,0,0],[0,1,0],[0,0,0],[0,0,1],[0,0,0],[-1,0,0],[0,0,0],[0,-1,0],[0,0,0],[0,0,-1]];const colors=[[1,0,0,1],[1,0,0,1],[0,1,0,1],[0,1,0,1],[0,0,1,1],[0,0,1,1],[0,1,1,1],[0,1,1,1],[1,0,1,1],[1,0,1,1],[1,1,0,1],[1,1,0,1]];const normals=[[1,0,0],[1,0,0],[0,1,0],[0,1,0],[0,0,1],[0,0,1],[-1,0,0],[-1,0,0],[0,-1,0],[0,-1,0],[0,0,-1],[0,0,-1]];return{mode:"LINES",vertexCount:12,attribs:{position:new Float32Array(positions.flat(2)),color:new Float32Array(colors.flat(2)),normal:new Float32Array(normals.flat(2))}}}var primitives=Object.freeze({__proto__:null,_axes:_axes,_fsQuad:_fsQuad,circle:circle,cube:cube,grid:grid,icosphere:icosphere,quad:quad});const EPSILON=1e-7;function create(){let out;{out=new Array(16).fill(0)}out[0]=1;out[5]=1;out[10]=1;out[15]=1;return out}function lookAt(out,eye,center,up){let x0,x1,x2,y0,y1,y2,z0,z1,z2,len;let eyex=eye[0];let eyey=eye[1];let eyez=eye[2];let upx=up[0];let upy=up[1];let upz=up[2];let centerx=center[0];let centery=center[1];let centerz=center[2];if(Math.abs(eyex-centerx)<EPSILON&&Math.abs(eyey-centery)<EPSILON&&Math.abs(eyez-centerz)<EPSILON){return out}z0=eyex-centerx;z1=eyey-centery;z2=eyez-centerz;len=1/Math.hypot(z0,z1,z2);z0*=len;z1*=len;z2*=len;x0=upy*z2-upz*z1;x1=upz*z0-upx*z2;x2=upx*z1-upy*z0;len=Math.hypot(x0,x1,x2);if(!len){x0=0;x1=0;x2=0}else{len=1/len;x0*=len;x1*=len;x2*=len}y0=z1*x2-z2*x1;y1=z2*x0-z0*x2;y2=z0*x1-z1*x0;len=Math.hypot(y0,y1,y2);if(!len){y0=0;y1=0;y2=0}else{len=1/len;y0*=len;y1*=len;y2*=len}out[0]=x0;out[1]=y0;out[2]=z0;out[3]=0;out[4]=x1;out[5]=y1;out[6]=z1;out[7]=0;out[8]=x2;out[9]=y2;out[10]=z2;out[11]=0;out[12]=-(x0*eyex+x1*eyey+x2*eyez);out[13]=-(y0*eyex+y1*eyey+y2*eyez);out[14]=-(z0*eyex+z1*eyey+z2*eyez);out[15]=1;return out}function perspective(out,fovy,aspect,near,far){const f=1/Math.tan(fovy/2);out[0]=f/aspect;out[1]=0;out[2]=0;out[3]=0;out[4]=0;out[5]=f;out[6]=0;out[7]=0;out[8]=0;out[9]=0;out[11]=-1;out[12]=0;out[13]=0;out[15]=0;if(far!=null&&far!==Infinity){const nf=1/(near-far);out[10]=(far+near)*nf;out[14]=2*far*near*nf}else{out[10]=-1;out[14]=-2*near}return out}function translate(out,a,v){let x=v[0],y=v[1],z=v[2];let a00,a01,a02,a03;let a10,a11,a12,a13;let a20,a21,a22,a23;if(a===out){out[12]=a[0]*x+a[4]*y+a[8]*z+a[12];out[13]=a[1]*x+a[5]*y+a[9]*z+a[13];out[14]=a[2]*x+a[6]*y+a[10]*z+a[14];out[15]=a[3]*x+a[7]*y+a[11]*z+a[15]}else{a00=a[0];a01=a[1];a02=a[2];a03=a[3];a10=a[4];a11=a[5];a12=a[6];a13=a[7];a20=a[8];a21=a[9];a22=a[10];a23=a[11];out[0]=a00;out[1]=a01;out[2]=a02;out[3]=a03;out[4]=a10;out[5]=a11;out[6]=a12;out[7]=a13;out[8]=a20;out[9]=a21;out[10]=a22;out[11]=a23;out[12]=a00*x+a10*y+a20*z+a[12];out[13]=a01*x+a11*y+a21*z+a[13];out[14]=a02*x+a12*y+a22*z+a[14];out[15]=a03*x+a13*y+a23*z+a[15]}}function rotate(out,a,rad,axis){let x=axis[0],y=axis[1],z=axis[2];let len=Math.hypot(x,y,z);let s,c,t;let a00,a01,a02,a03;let a10,a11,a12,a13;let a20,a21,a22,a23;let b00,b01,b02;let b10,b11,b12;let b20,b21,b22;if(len<EPSILON){return null}len=1/len;x*=len;y*=len;z*=len;s=Math.sin(rad);c=Math.cos(rad);t=1-c;a00=a[0];a01=a[1];a02=a[2];a03=a[3];a10=a[4];a11=a[5];a12=a[6];a13=a[7];a20=a[8];a21=a[9];a22=a[10];a23=a[11];b00=x*x*t+c;b01=y*x*t+z*s;b02=z*x*t-y*s;b10=x*y*t-z*s;b11=y*y*t+c;b12=z*y*t+x*s;b20=x*z*t+y*s;b21=y*z*t-x*s;b22=z*z*t+c;out[0]=a00*b00+a10*b01+a20*b02;out[1]=a01*b00+a11*b01+a21*b02;out[2]=a02*b00+a12*b01+a22*b02;out[3]=a03*b00+a13*b01+a23*b02;out[4]=a00*b10+a10*b11+a20*b12;out[5]=a01*b10+a11*b11+a21*b12;out[6]=a02*b10+a12*b11+a22*b12;out[7]=a03*b10+a13*b11+a23*b12;out[8]=a00*b20+a10*b21+a20*b22;out[9]=a01*b20+a11*b21+a21*b22;out[10]=a02*b20+a12*b21+a22*b22;out[11]=a03*b20+a13*b21+a23*b22;if(a!==out){out[12]=a[12];out[13]=a[13];out[14]=a[14];out[15]=a[15]}return out}function identity(out){out[0]=1;out[1]=0;out[2]=0;out[3]=0;out[4]=0;out[5]=1;out[6]=0;out[7]=0;out[8]=0;out[9]=0;out[10]=1;out[11]=0;out[12]=0;out[13]=0;out[14]=0;out[15]=1;return out}function multiply(out,a,b){let a00=a[0],a01=a[1],a02=a[2],a03=a[3];let a10=a[4],a11=a[5],a12=a[6],a13=a[7];let a20=a[8],a21=a[9],a22=a[10],a23=a[11];let a30=a[12],a31=a[13],a32=a[14],a33=a[15];let b0=b[0],b1=b[1],b2=b[2],b3=b[3];out[0]=b0*a00+b1*a10+b2*a20+b3*a30;out[1]=b0*a01+b1*a11+b2*a21+b3*a31;out[2]=b0*a02+b1*a12+b2*a22+b3*a32;out[3]=b0*a03+b1*a13+b2*a23+b3*a33;b0=b[4];b1=b[5];b2=b[6];b3=b[7];out[4]=b0*a00+b1*a10+b2*a20+b3*a30;out[5]=b0*a01+b1*a11+b2*a21+b3*a31;out[6]=b0*a02+b1*a12+b2*a22+b3*a32;out[7]=b0*a03+b1*a13+b2*a23+b3*a33;b0=b[8];b1=b[9];b2=b[10];b3=b[11];out[8]=b0*a00+b1*a10+b2*a20+b3*a30;out[9]=b0*a01+b1*a11+b2*a21+b3*a31;out[10]=b0*a02+b1*a12+b2*a22+b3*a32;out[11]=b0*a03+b1*a13+b2*a23+b3*a33;b0=b[12];b1=b[13];b2=b[14];b3=b[15];out[12]=b0*a00+b1*a10+b2*a20+b3*a30;out[13]=b0*a01+b1*a11+b2*a21+b3*a31;out[14]=b0*a02+b1*a12+b2*a22+b3*a32;out[15]=b0*a03+b1*a13+b2*a23+b3*a33;return out}function copy(out,a){out[0]=a[0];out[1]=a[1];out[2]=a[2];out[3]=a[3];out[4]=a[4];out[5]=a[5];out[6]=a[6];out[7]=a[7];out[8]=a[8];out[9]=a[9];out[10]=a[10];out[11]=a[11];out[12]=a[12];out[13]=a[13];out[14]=a[14];out[15]=a[15];return out}function scale(out,a,v){let x=v[0],y=v[1],z=v[2];out[0]=a[0]*x;out[1]=a[1]*x;out[2]=a[2]*x;out[3]=a[3]*x;out[4]=a[4]*y;out[5]=a[5]*y;out[6]=a[6]*y;out[7]=a[7]*y;out[8]=a[8]*z;out[9]=a[9]*z;out[10]=a[10]*z;out[11]=a[11]*z;out[12]=a[12];out[13]=a[13];out[14]=a[14];out[15]=a[15];return out}function invert(out,a){let a00=a[0],a01=a[1],a02=a[2],a03=a[3];let a10=a[4],a11=a[5],a12=a[6],a13=a[7];let a20=a[8],a21=a[9],a22=a[10],a23=a[11];let a30=a[12],a31=a[13],a32=a[14],a33=a[15];let b00=a00*a11-a01*a10;let b01=a00*a12-a02*a10;let b02=a00*a13-a03*a10;let b03=a01*a12-a02*a11;let b04=a01*a13-a03*a11;let b05=a02*a13-a03*a12;let b06=a20*a31-a21*a30;let b07=a20*a32-a22*a30;let b08=a20*a33-a23*a30;let b09=a21*a32-a22*a31;let b10=a21*a33-a23*a31;let b11=a22*a33-a23*a32;let det=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;if(!det){return null}det=1/det;out[0]=(a11*b11-a12*b10+a13*b09)*det;out[1]=(a02*b10-a01*b11-a03*b09)*det;out[2]=(a31*b05-a32*b04+a33*b03)*det;out[3]=(a22*b04-a21*b05-a23*b03)*det;out[4]=(a12*b08-a10*b11-a13*b07)*det;out[5]=(a00*b11-a02*b08+a03*b07)*det;out[6]=(a32*b02-a30*b05-a33*b01)*det;out[7]=(a20*b05-a22*b02+a23*b01)*det;out[8]=(a10*b10-a11*b08+a13*b06)*det;out[9]=(a01*b08-a00*b10-a03*b06)*det;out[10]=(a30*b04-a31*b02+a33*b00)*det;out[11]=(a21*b02-a20*b04-a23*b00)*det;out[12]=(a11*b07-a10*b09-a12*b06)*det;out[13]=(a00*b09-a01*b07+a02*b06)*det;out[14]=(a31*b01-a30*b03-a32*b00)*det;out[15]=(a20*b03-a21*b01+a22*b00)*det;return out}function transformMat4(out,a,m){let x=a[0],y=a[1],z=a[2];let w=m[3]*x+m[7]*y+m[11]*z+m[15];w=w||1;out[0]=(m[0]*x+m[4]*y+m[8]*z+m[12])/w;out[1]=(m[1]*x+m[5]*y+m[9]*z+m[13])/w;out[2]=(m[2]*x+m[6]*y+m[10]*z+m[14])/w;return out}var m4=Object.freeze({__proto__:null,copy:copy,create:create,identity:identity,invert:invert,lookAt:lookAt,multiply:multiply,perspective:perspective,rotate:rotate,scale:scale,transformMat4:transformMat4,translate:translate});class Transform{constructor(){this.position=new Vec3;this.rotation=new Vec3;this.scale=new Vec3(1,1,1);this._matrix=create();this._changed=false}_updateMatrix(){identity(this._matrix);translate(this._matrix,this._matrix,this.position.xyz);rotate(this._matrix,this._matrix,this.rotation.x,[1,0,0]);rotate(this._matrix,this._matrix,this.rotation.y,[0,1,0]);rotate(this._matrix,this._matrix,this.rotation.z,[0,0,1]);scale(this._matrix,this._matrix,this.scale.xyz)}get changed(){if(this.rotation._changed||this.position._changed||this.scale._changed){this.position._changed=false;this.rotation._changed=false;this.scale._changed=false;return true}return false}get matrix(){if(this.changed){this._updateMatrix()}return this._matrix}}class Node{constructor(name,geometry,transform){this.name=name;this.id=this.generateId();this.geometry=geometry||null;this.transform=transform||new Transform;this.visible=true;this.parent=null;this.children=[];this._worldMatrix=create();this.uniforms={uObjectId:this.id,uModel:this._worldMatrix,uTex:"none"}}get x(){return this.transform.position.x}get y(){return this.transform.position.y}get z(){return this.transform.position.z}get rx(){return this.transform.rotation.x}get ry(){return this.transform.rotation.y}get rz(){return this.transform.rotation.z}move(x,y,z){this.transform.position.set(x,y,z);return this}rotate(x,y,z){this.transform.rotation.set(x,y,z);return this}scale(x){this.transform.scale.set(x,x,x);return this}get worldPosition(){return[this._worldMatrix[12],this._worldMatrix[13],this._worldMatrix[14]]}_calculateWorldMatrix(parent){if(parent){multiply(this._worldMatrix,parent._worldMatrix,this.transform.matrix)}else{copy(this._worldMatrix,this.transform.matrix)}this.children.forEach((child=>{child._calculateWorldMatrix(this)}))}setParent(node){if(this.parent){this.parent._removeChild(this)}this.parent=node;this.parent._addChild(this);this._dirty=true;return this}setGeometry(geo){this.geometry=geo;return this}createChildNode(name,geometry){let node=new Node(name,geometry);node.setParent(this);return node}generateId(){let id="";for(let i=0;i<4;i++){id+=Math.floor(Math.random()*10)}return id}_removeChild(node){this.children=this.children.filter((n=>n!==node))}_addChild(node){this.children.push(node);this._dirty=true}_print(output,depth){if(depth>0){for(let i=1;i<depth;i++){output+="  "}output+="└─"}const geometry=this.geometry?"m."+this.geometry:"";output+=`<em>${this.name}</em> : ${geometry}`;output+="\n";if(this.children){output+=this.children.map((c=>c._print("",depth+1))).join("")}return output}_toDrawList(drawList,children=true){if(!this.visible){return}if(this.geometry){drawList.push(this)}if(children){this.children.forEach((child=>child._toDrawList(drawList)))}return drawList}traverse(fn){fn(this);this.children.forEach((child=>child.traverse(fn)))}uniform(name,value){this.uniforms[name]=value}}class Camera extends Node{constructor(transform,fov){super("camera",null,transform);this.fov=fov||35;this.near=.5;this.far=100;this.view=create();this.projection=create();this.target=new Vec3(0,0,0);this.updateViewProjection()}get eye(){return this.worldPosition}set aspect(val){this._aspect=val}updateViewProjection(){lookAt(this.view,this.eye,this.target.xyz,[0,1,0]);perspective(this.projection,radians(this.fov),this._aspect,this.near,this.far)}}class Scene extends Node{constructor(){super("scene",null);this.camera=new Camera;this.camera.setParent(this);this._drawCalls=[]}print(){return this._print("* ",0)}drawCalls(){this._drawCalls=[];return this._toDrawList(this._drawCalls)}add(){}updateSceneGraph(){this._calculateWorldMatrix()}}const graphStyle={width:"300px",height:"400px",position:"absolute",backgroundColor:"rgba(0,0,0,0.25)",left:"1em",top:"1em",zIndex:101,overflow:"hidden",whiteSpace:"pre",padding:"1em"};function SceneGraph(){let graph=tag("div#scene-graph",graphStyle);document.body.append(graph);return graph}const vertexAttributeLayout=[{name:"aPosition",size:3,type:"FLOAT",normalized:false},{name:"aNormal",size:3,type:"FLOAT",normalized:false},{name:"aTexCoord",size:2,type:"FLOAT",normalized:false},{name:"aColor",size:4,type:"FLOAT",normalized:false},{name:"aSurfaceId",size:1,type:"FLOAT",normalized:false},{name:"aRegister1",size:4,type:"FLOAT",normalized:false},{name:"aRegister2",size:4,type:"FLOAT",normalized:false}];class RendererGL2{constructor(canvas,w,h,config){this.canvas=canvas;this.canvas.width=w;this.canvas.height=h;this.aspectRatio=w/h;this.glSettings={antialias:false,preserveDrawingBuffer:true};if(config){Object.assign(this.glSettings,config)}this.gl=canvas.getContext("webgl2",this.glSettings);if(!this.gl){console.warn("Web GL 2 not available!");return}this._configuration={depthTest:true,depthWrite:true,faceCulling:"back"};this._configure(config);this.shaderPrograms={};this.shaderProgramUniforms={};this.renderTargets={canvas:null,default:null};this.clearColor=[0,0,0,1];this.activeProgram;this.renderTarget;this.textureUnitIndex=0;this.uniformTypes={FLOAT:"uniform1f",FLOAT_VEC2:"uniform2fv",FLOAT_VEC3:"uniform3fv",FLOAT_VEC4:"uniform4fv",FLOAT_MAT4:"uniformMatrix4fv",SAMPLER_2D:"uniform1i"};this.meshes={};this.texturesByName={};this.vertexAttributes=[...vertexAttributeLayout];if(config.attributes){this.vertexAttributes.push(...config.attributes)}this.attributeInfoByName={};this.vertexAttributes.forEach(((attrib,i)=>{this.attributeInfoByName[attrib.name]=attrib;this.attributeInfoByName[attrib.name].index=i}))}_configure(settings){if(settings){for(let setting in settings){this._configuration[setting]=settings[setting]}}this.depthTest(this._configuration.depthTest);this.depthWrite(this._configuration.depthWrite);this.cullFace(this._configuration.faceCulling)}depthTest(flag){const gl=this.gl;this._configuration.depthTest=flag;gl.disable(gl.DEPTH_TEST);if(flag){gl.enable(gl.DEPTH_TEST)}}depthWrite(flag){const gl=this.gl;this._configuration.depthWrite=flag;gl.depthMask(flag)}cullFace(face){const gl=this.gl;this._configuration.faceCulling=face;switch((""+face).toUpperCase()){case"NONE":gl.disable(gl.CULL_FACE);break;case"ALL":gl.enable(gl.CULL_FACE);gl.cullFace(gl.FRONT_AND_BACK);break;case"FRONT":gl.enable(gl.CULL_FACE);gl.cullFace(gl.FRONT);break;case"BACK":gl.enable(gl.CULL_FACE);gl.cullFace(gl.BACK);break;default:gl.disable(gl.CULL_FACE)}}_prefixAttribName(name){if(name[0]==="a"){return name}return"a"+name[0].toUpperCase()+name.slice(1)}setProgram(program){if(!this.shaderPrograms[program]){return}if(this.activeProgram===program){return}this.gl.useProgram(this.shaderPrograms[program]);this.activeProgram=program}setRenderTarget(target){if(target===null||this.renderTargets[target]===null){this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,null);this.renderTarget=null;return}if(this.renderTargets[target]===undefined){return}if(this.renderTarget===target){return}const rt=this.renderTargets[target];const frameBuffer=rt.frameBuffer;this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,frameBuffer);this.renderTarget=target}createRenderTarget(name,depth){const target={};const gl=this.gl;target.colorTexUnit=this.textureUnitIndex;target.colorTexture=gl.createTexture();this.texturesByName[name+".color"]={unit:target.colorTexUnit,texture:target.colorTexture};this.textureUnitIndex++;gl.activeTexture(gl.TEXTURE0+target.colorTexUnit);gl.bindTexture(gl.TEXTURE_2D,target.colorTexture);gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,this.canvas.width,this.canvas.height,0,gl.RGBA,gl.UNSIGNED_BYTE,null);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);target.frameBuffer=gl.createFramebuffer();gl.bindFramebuffer(gl.FRAMEBUFFER,target.frameBuffer);gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,target.colorTexture,0);if(depth){target.depthTexUnit=this.textureUnitIndex;target.depthTexture=gl.createTexture();this.texturesByName[name+".depth"]={unit:target.depthTexUnit,texture:target.depthTexture};gl.activeTexture(gl.TEXTURE0+target.depthTexUnit);gl.bindTexture(gl.TEXTURE_2D,target.depthTexture);gl.texImage2D(gl.TEXTURE_2D,0,gl.DEPTH_COMPONENT24,this.canvas.width,this.canvas.height,0,gl.DEPTH_COMPONENT,gl.UNSIGNED_INT,null);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.DEPTH_ATTACHMENT,gl.TEXTURE_2D,target.depthTexture,0)}this.renderTargets[name]=target}draw(mesh){if(!this.meshes[mesh]){console.warn("No mesh found:",mesh);return}const call=this.meshes[mesh];this.gl.bindVertexArray(call.vao);this.gl.drawArrays(this.gl[call.data.mode],0,call.data.vertexCount);this.gl.bindVertexArray(null)}findUniformType(typePointer){for(let namedType of Object.keys(this.uniformTypes)){if(this.gl[namedType]===typePointer){return namedType}}return false}createProgram(name,vert,frag){const program=this.gl.createProgram();const vertexShader=this.gl.createShader(this.gl.VERTEX_SHADER);this.gl.shaderSource(vertexShader,vert);this.gl.compileShader(vertexShader);this.gl.attachShader(program,vertexShader);const fragmentShader=this.gl.createShader(this.gl.FRAGMENT_SHADER);this.gl.shaderSource(fragmentShader,frag);this.gl.compileShader(fragmentShader);this.gl.attachShader(program,fragmentShader);this.bindVertexAttributeLocations(program);this.gl.linkProgram(program);if(!this.gl.getProgramParameter(program,this.gl.LINK_STATUS)){console.log(this.gl.getShaderInfoLog(vert));console.log(this.gl.getShaderInfoLog(frag));return}const uniformBlock={};const uniformCount=this.gl.getProgramParameter(program,this.gl.ACTIVE_UNIFORMS);for(let i=0;i<uniformCount;i++){const uniformInfo=this.gl.getActiveUniform(program,i);const{size:size,type:type,name:name}=uniformInfo;let namedType=this.findUniformType(type);if(!namedType){continue}uniformBlock[name]={type:namedType,location:this.gl.getUniformLocation(program,name)}}this.shaderPrograms[name]=program;this.shaderProgramUniforms[name]=uniformBlock;return program}bindVertexAttributeLocations(program){for(let i=0;i<this.vertexAttributes.length;i++){const attrib=this.vertexAttributes[i];this.gl.bindAttribLocation(program,i,attrib.name)}}_bufferAttribs(vao,attribs){const gl=this.gl;gl.bindVertexArray(vao);for(const[attrib,data]of Object.entries(attribs)){const attribName=this._prefixAttribName(attrib);const attribInfo=this.attributeInfoByName[attribName];if(!attribInfo){continue}console.log({attrib:attrib,attribName:attribName,attribInfo:attribInfo,data:data});const buffer=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,buffer);gl.bufferData(gl.ARRAY_BUFFER,data,gl.STATIC_DRAW);const{index:index,size:size,type:type,normalized:normalized}=attribInfo;gl.vertexAttribPointer(index,size,gl[type],normalized,0,0);gl.enableVertexAttribArray(index)}gl.bindVertexArray(null)}_getMeshId(name){const n=name.toLowerCase();let postFix="";let num=1;while(this.meshes[n+postFix]){postFix="."+(""+num).padStart(3,"0");num+=1}return n+postFix}addMesh(meshData){let data;if(meshData.render){data=data.render()}else{data=meshData}let name=data.name||"mesh";name=this._getMeshId(name);if(this.meshes[name]){this.updateMesh(name,data);return}const mesh={data:data};data.name=name;mesh.vao=this.gl.createVertexArray();console.log("buffering",name,mesh);this._bufferAttribs(mesh.vao,data.attribs);this.meshes[name]=mesh;return name}updateMesh(name,data){if(!this.meshes[name]){return}const mesh=this.meshes[name];this.gl.deleteVertexArray(mesh.vao);mesh.data=data;mesh.vao=this.gl.createVertexArray();this._bufferAttribs(mesh.vao,data.attribs)}uniform(name,value){const uniforms=this.shaderProgramUniforms[this.activeProgram];if(!uniforms[name]){return}const{type:type,location:location}=uniforms[name];if(type.indexOf("MAT")>-1){this.gl[this.uniformTypes[type]](location,false,value);return}if(typeof value==="string"&&this.texturesByName[value]!==undefined){const unit=this.texturesByName[value].unit;this.gl[this.uniformTypes[type]](location,unit);return}this.gl[this.uniformTypes[type]](location,value)}clear(color){this.gl.clearColor(...color);this.gl.clear(this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT)}clearDepth(){this.gl.clear(this.gl.DEPTH_BUFFER_BIT)}hardFind(pointer){for(const[key,value]of Object.entries(this.gl.constructor)){if(typeof value!=="number"){continue}if(value===pointer){console.log(key);return key}}}addTexture(name,imageData,settings){const gl=this.gl;if(this.textureUnitIndex>=7){return}let unit,texture;if(this.texturesByName[name]){unit=this.texturesByName[name].unit;texture=this.texturesByName[name].texture}else{unit=this.textureUnitIndex;texture=gl.createTexture();this.texturesByName[name]={unit:unit,texture:texture};this.textureUnitIndex++}gl.activeTexture(gl.TEXTURE0+unit);gl.bindTexture(gl.TEXTURE_2D,texture);gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,true);const{width:width,height:height,filter:filter,clamp:clamp}=settings;gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,width,height,0,gl.RGBA,gl.UNSIGNED_BYTE,imageData);if(clamp){gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE)}gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl[filter]);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl[filter]);return unit}totalVertices(){return Object.values(this.meshes).reduce(((a,b)=>a+b.data.vertexCount),0)}}class PlyLoader{constructor(verbose=false){this._filesToLoad=[];this._isLoading=false;this.RETURN=10;this.SPACE=32;this.END_HEADER="end_header";this._verbose=verbose;this.PLY_TYPES={char:{bytes:1,getter:"getInt8"},uchar:{bytes:1,getter:"getUint8"},short:{bytes:2,getter:"getInt16"},ushort:{bytes:2,getter:"getUint16"},int:{bytes:4,getter:"getInt32"},uint:{bytes:4,getter:"getUint32"},float:{bytes:4,getter:"getFloat32"},double:{bytes:8,getter:"getFloat64"}};this.PLY_MAPPINGS={x:{attrib:"position",index:0},y:{attrib:"position",index:1},z:{attrib:"position",index:2},nx:{attrib:"normal",index:0},ny:{attrib:"normal",index:1},nz:{attrib:"normal",index:2},s:{attrib:"texCoord",index:0},t:{attrib:"texCoord",index:1},red:{attrib:"color",index:0},green:{attrib:"color",index:1},blue:{attrib:"color",index:2},alpha:{attrib:"color",index:3}}}async load(file,fn){if(this._isLoading){this._filesToLoad.push([file,fn]);return}const response=await fetch(file);if(!response.ok){console.error("Error fetching "+file);this._finishLoading();return}const buffer=await response.arrayBuffer();const header=this._parseHeader(buffer);if(!header.valid){console.error("Malformed data. Missing ply header: "+file);this._finishLoading();return}let[vertices,faces]=this._unpackData(buffer,header);vertices=this._unfoldVertices(vertices,header.vertexFormat);faces=this._trimFaces(faces);const mesh=new Mesh(vertices,faces,{name:file});if(this._verbose){console.log(`Loaded ${file} with ${vertices.length} vertices.`)}if(fn&&typeof fn==="function"){fn(mesh)}this._finishLoading()}_finishLoading(){this._isLoading=false;if(this._filesToLoad.length){this.load(...this._filesToLoad.shift())}}_bufferToHeaderStrings(buffer){const chars=new Uint8Array(buffer);const headerStrings=[];let charIndex=0;let currentLine="";while(charIndex<chars.length){const charCode=chars[charIndex];if(charCode===this.RETURN){headerStrings.push(currentLine);if(currentLine===this.END_HEADER){break}currentLine=""}else{currentLine+=String.fromCharCode(charCode)}charIndex++}return headerStrings}_parseHeader(buffer){const headerStrings=this._bufferToHeaderStrings(buffer);const header={valid:false,format:null,vertexCount:0,vertexFormat:[],vertexStart:0,bytesPerVertex:0,totalVertexBytes:0,faceCount:0,faceFormat:[],faceStart:0};let headerByteLength=0;let mode="vertex";for(const str of headerStrings){headerByteLength+=str.length+1;const values=str.split(" ");switch(values[0]){case"ply":header.valid=true;break;case"format":header.format=values[1];break;case"comment":break;case"element":if(values[1]==="vertex"){header.vertexCount=parseInt(values[2]);mode="vertex"}else if(values[1]==="face"){header.faceCount=parseInt(values[2]);mode="face"}break;case"property":if(mode==="vertex"){const type=values[1],property=values[2];header.vertexFormat.push({type:type,property:property});header.bytesPerVertex+=this.PLY_TYPES[type].bytes}else{header.faceFormat=values.slice(1)}break}}header.vertexStart=headerByteLength;if(header.format==="ascii");header.totalVertexBytes=header.vertexCount*header.bytesPerVertex;header.faceStart=header.vertexStart+header.totalVertexBytes;return header}_trimFaces(faces){return faces.map((face=>face.slice(1)))}_unfoldVertex(vertex,format){const v={};for(let i=0;i<format.length;i++){const property=format[i].property;const{attrib:attrib,index:index}=this.PLY_MAPPINGS[property];if(!v[attrib]){v[attrib]=[]}v[attrib][index]=vertex[i]}return v}_unfoldVertices(vertices,format){return vertices.map((vertex=>this._unfoldVertex(vertex,format)))}_unpackData(buffer,header){if(header.format==="ascii"){return this._unpackDataAscii(buffer,header)}return this._unpackDataBinary(buffer,header)}_unpackDataAscii(buffer,header){const byteArray=new Uint8Array(buffer);const vertices=[];const faces=[];let currentValue="";let currentArray=[];for(let i=header.vertexStart;i<byteArray.length;i++){const charCode=byteArray[i];switch(charCode){case this.SPACE:currentArray.push(Number(currentValue));currentValue="";break;case this.RETURN:currentArray.push(Number(currentValue));currentValue="";if(vertices.length<header.vertexCount){vertices.push(currentArray)}else{faces.push(currentArray)}currentArray=[];break;default:currentValue+=String.fromCharCode(charCode);break}}return[vertices,faces]}_unpackDataBinary(buffer,header){const view=new DataView(buffer);const{vertexFormat:vertexFormat,faceFormat:faceFormat}=header;const littleEndian=header.format==="binary_little_endian";const vertices=[];const faces=[];const unpackVert=start=>{const vertex=[];let byteIndex=start;for(let{type:type}of vertexFormat){const{bytes:bytes,getter:getter}=this.PLY_TYPES[type];vertex.push(view[getter](byteIndex,littleEndian));byteIndex+=bytes}return vertex};const unpackFace=start=>{const face=[];let bytesConsumed=0;let byteIndex=start;const vertexCountType=this.PLY_TYPES[faceFormat[1]];const vertexIndexType=this.PLY_TYPES[faceFormat[2]];const vertexCount=view[vertexCountType.getter](byteIndex,littleEndian);face.push(vertexCount);bytesConsumed+=vertexCountType.bytes;byteIndex+=vertexCountType.bytes;for(let v=0;v<vertexCount;v++){const index=view[vertexIndexType.getter](byteIndex,littleEndian);face.push(index);bytesConsumed+=vertexIndexType.bytes;byteIndex+=vertexIndexType.bytes}return{bytesConsumed:bytesConsumed,face:face}};for(let v=0;v<header.vertexCount;v++){const start=header.vertexStart+v*header.bytesPerVertex;vertices.push(unpackVert(start))}let faceStartIndex=header.faceStart;for(let f=0;f<header.faceCount;f++){const{bytesConsumed:bytesConsumed,face:face}=unpackFace(faceStartIndex);faces.push(face);faceStartIndex+=bytesConsumed}return[vertices,faces]}}class Texer{constructor(size,feltApp){this.texerStyle={position:"absolute",bottom:"1em",right:"1em",zIndex:"200",background:"#111"};this.size=size;this.id="texer."+generateId();this.canvas=tag("canvas.texer",this.texerStyle);select(".felt-panel").append(this.canvas);this.canvas.width=size;this.canvas.height=size;this.ctx=this.canvas.getContext("2d");this.textureSettings={width:size,height:size,clamp:true,filter:"NEAREST"};this.style="#111";this._changed=false;this.fill(this.style);this.pixels(0,0,size,size)}fill(col){this.style=col;this.ctx.fillStyle=col;return this}pixels(x1,y1,x2,y2){this.ctx.fillRect(x1,y1,x2-x1,y2-y1);this._changed=true;return this}clear(){this.pixels(0,0,this.size,this.size);this._changed=true;return this}changed(){const c=this._changed;this._changed=false;return c}}const g={sin:Math.sin,cos:Math.cos,vec2:(x,y)=>new Vec2(x,y),vec3:(x,y,z)=>new Vec3(x,y,z),Vec2:Vec2,Vec3:Vec3,Mesh:Mesh,Texer:Texer,m4:m4};_inlineModule(common);_inlineModule(dom,"dom");_inlineModule(primitives,"shapes");_inlineModule(meshOps,"meshops");g._usedColors={};g.color=function(...args){const argString=args.join("");if(this._usedColors[argString]){return this._usedColors[argString]}const color$1=color(...args);this._usedColors[argString]=color$1;return color$1}.bind(g);class Gum{constructor(canvas,w,h,settings){settings=settings||{};this.canvas=select(canvas);this.renderer=new RendererGL2(this.canvas,w,h,settings);const scale=settings?.scale??1;this.canvas.style.transform=`scale(${scale})`;this.gl=this.renderer.gl;this.scene=new Scene;this.camera=this.scene.camera;this.camera.move(0,3,5);this.sceneGraph=SceneGraph();this.plyLoader=new PlyLoader(true);this._loop=true;this._timeAtLaunch=performance.now();this._timeAtLastInfo=performance.now();this._frame=0;this._lastNow=0;this.texers=[];this.postProcessingStack={frameBufferTex:null,frameBufferDepth:null,effects:[]};this.tick=this._tick.bind(this);this._imMatrix=create();this.defaultPass="unlit";this._info()}_setup(){if(this.vert&&this.frag){this.renderer.createProgram("default",this.vert,this.frag);return}const{vert:vert,frag:frag}=shaders[this.defaultPass];this.renderer.createProgram("default",vert,frag);this.renderer.addTexture("none",new Uint8Array([255,0,255,255]),{width:1,height:1,clamp:true,filter:"NEAREST"})}run(setup,draw){this._setup();setup();this._info();this._draw=draw;this._tick()}background(color){if(color instanceof Color){this.renderer.clear(color.rgba);return}if(Array.isArray(color)){this.renderer(clear(color))}}_tick(){let now=performance.now();let delta=.001*(now-this._lastNow)/(1/60);this._lastNow=now;identity(this._imMatrix);this.renderer.setProgram("default");this.renderer.setRenderTarget(null);if(this._loop&&this._draw){this._preDraw();this._draw(delta);this._postDraw()}const elapsed=now-this._timeAtLastInfo;if(elapsed>1e3){this._info();this._timeAtLastInfo=now}window.requestAnimationFrame(this.tick)}_info(){this.sceneGraph.innerHTML="";const verts=(this.renderer.totalVertices()/1e3).toFixed(1);this.sceneGraph.innerHTML+="verts: "+verts+"k\n";this.sceneGraph.innerHTML+=this.scene.print()}loop(val){this._loop=val}time(){return performance.now()-this._timeAtLaunch}loadMesh(model,fn){this.plyLoader.load("/models/"+model,(function(mesh){if(fn){mesh=fn(mesh)}this.renderer.addMesh(fn(mesh))}))}addTexer(texer){this.texers.push(texer);this.renderer.addTexture(texer.id,texer.canvas,texer.textureSettings)}axes(){if(!this._axes){this._axes=this.renderer.addMesh(_axes())}this.renderer.uniform("uModel",this.scene.transform.matrix);this.renderer.draw(this._axes)}node(name){return this.scene.createChildNode(name,null)}addMesh(mesh){if(mesh.render){return this.renderer.addMesh(mesh.render())}return this.renderer.addMesh(mesh)}_preDraw(){this.renderer.setProgram("default");this.renderer.setRenderTarget("default");const dWidth=this.canvas.clientWidth;const dHeight=this.canvas.clientHeight;const needsResize=this.canvas.width!==dWidth||this.canvas.height!==dHeight;if(needsResize){this.canvas.width=dWidth;this.canvas.height=dHeight}this.gl.viewport(0,0,this.canvas.width,this.canvas.height);this.camera.aspect=this.canvas.clientWidth/this.canvas.clientHeight;this.camera.updateViewProjection();this.renderer.uniform("uNear",this.camera.near);this.renderer.uniform("uFar",this.camera.far);this.renderer.uniform("uEye",this.camera.eye);this.renderer.uniform("uView",this.camera.view);this.renderer.uniform("uProjection",this.camera.projection);for(let texer of this.texers){if(texer.changed()){this.renderer.addTexture(texer.id,texer.canvas,texer.textureSettings)}}}_postDraw(){if(this.postProcessingStack.effects.length>0){const{frameBufferTex:frameBufferTex,frameBufferDepth:frameBufferDepth}=this.postProcessingStack;for(let effect of this.postProcessingStack.effects){this.renderer.setProgram(effect.program);this.renderer.setRenderTarget("canvas");this.renderer.uniform("uMainTex",frameBufferTex);this.renderer.uniform("uDepthTex",frameBufferDepth);this.renderer.uniform("uTexSize",[this.canvas.width,this.canvas.height]);this.renderer.uniform("uNear",this.camera.near);this.renderer.uniform("uFar",this.camera.far);this.renderer.clear([1,0,0,1]);this.renderer.draw("effect-quad")}}}addEffect(name,type){if(this.postProcessingStack.effects.length===0){this.renderer.createRenderTarget("frameBuffer",true);const targetInfo=this.renderer.renderTargets["frameBuffer"];this.postProcessingStack.frameBufferTex=targetInfo.colorTexUnit;this.postProcessingStack.frameBufferDepth=targetInfo.depthTexUnit;const fsQuad=_fsQuad();fsQuad.name="effect-quad";this.renderer.addMesh(fsQuad);this.renderer.renderTargets["default"]=targetInfo}const effect={name:name,program:name};const vert=shaders.post.vert;const frag=shaders["post-chromatic"].frag;this.renderer.createProgram(name,vert,frag);this.postProcessingStack.effects.push(effect)}drawScene(){this.scene.updateSceneGraph();this.renderer.uniform("uTex","none");for(let call of this.scene.drawCalls()){for(let[uniform,value]of Object.entries(call.uniforms)){this.renderer.uniform(uniform,value)}this.renderer.draw(call.geometry)}}drawNode(node,children=true){let draws=[];node._toDrawList(draws,children);for(let call of draws){for(let[uniform,value]of Object.entries(call.uniforms)){this.renderer.uniform(uniform,value)}this.renderer.draw(call.geometry)}}drawMesh(mesh){this.renderer.uniform("uModel",this._imMatrix);this.renderer.draw(mesh)}}function _inlineModule(module,target){let targetObj=g;if(target){if(g[target]){targetObj=g[target]}else{targetObj={};g[target]=targetObj}}for(const fn in module){if(typeof module[fn]==="function"&&fn[0]!=="_"){if(!(fn in window)){targetObj[fn]=module[fn]}}}}exports.Gum=Gum;exports.g=g;return exports}({});